
<!DOCTYPE html>
<html lang="zh-CN ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AprilNAVI&#39;s Blog | You are the best || 计算机图形学入门（笔记）（更新中）</title>
    <meta name="author" content="AprilNAVI">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://i.loli.net/2021/04/11/ntQaX3ly1ohHNGr.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">AprilNAVI's Blog | You are the best</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>AprilNAVI's Blog | You are the best</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>计算机图形学入门（笔记）（更新中） </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2021/4/22
        </span>

        

        
    </div>

    <div class="content" v-pre>
        <p>闫令琪教授的games101课程笔记哒</p>
<span id="more"></span>

<h1 id="1-Review-of-Linear-Algebra（线性变换总览）"><a href="#1-Review-of-Linear-Algebra（线性变换总览）" class="headerlink" title="1.Review of Linear Algebra（线性变换总览）"></a>1.Review of Linear Algebra（线性变换总览）</h1><p>vector：（dot product，cross product）点乘，叉乘</p>
<p>matrices：（matrix-matrix，matrix-vector mult）矩阵和矩阵，矩阵和向量乘法</p>
<p><strong>vector：</strong></p>
<p>length of a vector written as (向量长度)<br>$$<br>\vert\vert\vec{a}\vert\vert<br>$$<br>unit vector as（单位向量）<br>$$<br>\hat a=\vec a/\vert\vert\vec{a}\vert\vert<br>$$</p>
<hr>
<h2 id="dot-product（点乘）"><a href="#dot-product（点乘）" class="headerlink" title="dot product（点乘）"></a>dot product（点乘）</h2><p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418114037370.png" alt="image-20210418114037370"></p>
<p>for is unit vector（对每个单位向量而言） ：<br>$$<br>\cos \theta=\hat a ·\hat b<br>$$<br>properties（属性）：</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418114720929.png" alt="image-20210418114720929"></p>
<p>in cartesian coordinates（在笛卡尔坐标系）：</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418114930611.png" alt="image-20210418114930611"></p>
<hr>
<p><strong>dot product in graphic：</strong></p>
<ul>
<li><p>find angle between two vectors</p>
<p>（e.g. cosine of angle between light source and surface）</p>
</li>
<li><p>find projection of one vector on another</p>
</li>
</ul>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418115359464.png" alt="image-20210418115359464"></p>
<p>other benefits of dot product:</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418115656407.png" alt="image-20210418115656407"></p>
<p>测量两个方向有多近</p>
<p>分解一个向量</p>
<p>确定两个向量是同向还是反向</p>
<hr>
<h2 id="cross-product（叉乘）"><a href="#cross-product（叉乘）" class="headerlink" title="cross product（叉乘）"></a>cross product（叉乘）</h2><p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418115836909.png" alt="image-20210418115836909"></p>
<p>叉积与两个初始向量正交，由右手法则定义方向，用于构造坐标</p>
<p><strong>properties：</strong></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418120226743.png" alt="image-20210418120226743"></p>
<p>对了顺带一提，OpenGL是右手系，DirectX，unity为左手系</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418120436013.png" alt="image-20210418120436013"></p>
<p><strong>dot product in graphic：</strong></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418120513504.png" alt="image-20210418120513504"></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418120557223.png" alt="image-20210418120557223"></p>
<p>叉积可以定义左和右，定义里和外。</p>
<h2 id="matrix（矩阵）"><a href="#matrix（矩阵）" class="headerlink" title="matrix（矩阵）"></a>matrix（矩阵）</h2><p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418120741005.png" alt="image-20210418120741005"></p>
<p>如图所示为3行2列矩阵。</p>
<p><strong>multiplication :</strong></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418120918703.png" alt="image-20210418120918703"></p>
<p><strong>properties :</strong></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418120951541.png" alt="image-20210418120951541"></p>
<p>妹有交换率啊！！</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418121058495.png" alt="image-20210418121058495"></p>
<p>在2d中对于Y轴对称</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418121158584.png" alt="image-20210418121158584"></p>
<p>AB的转置矩阵＝B的转置乘A的转置</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418121340439.png" alt="image-20210418121340439"></p>
<hr>
<p>点乘和叉乘在向量中的表示</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418122911370.png" alt="image-20210418122911370"></p>
<hr>
<p>4.18 12:31补完！</p>
<hr>
<h1 id="2-Transformation-（变换）"><a href="#2-Transformation-（变换）" class="headerlink" title="2.Transformation （变换）"></a>2.Transformation （变换）</h1><h2 id="the-formula-of-linear-transform（线性变换公式）"><a href="#the-formula-of-linear-transform（线性变换公式）" class="headerlink" title="the formula of linear transform（线性变换公式）"></a>the formula of linear transform（线性变换公式）</h2><p>不多bb直接上图，这节课都是公式：</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418123154366.png" alt="image-20210418123154366"></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418123303827.png" alt="image-20210418123303827"></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418123356265.png" alt="image-20210418123356265"></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418123421213.png" alt="image-20210418123421213"></p>
<h2 id="some-problem-of-linear-transform（线性变换遇到的问题）"><a href="#some-problem-of-linear-transform（线性变换遇到的问题）" class="headerlink" title="some problem of linear transform（线性变换遇到的问题）"></a>some problem of linear transform（线性变换遇到的问题）</h2><p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418123717722.png" alt="image-20210418123717722"></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418123508607.png" alt="image-20210418123508607"></p>
<p>then我们发现平移没办法用线性变换表示，所以我们引入”齐！次！坐！标！“</p>
<p><strong>homogeneous coordinates：</strong></p>
<p>引入第三个坐标系，用1表示点，用0表示坐标</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418124102213.png" alt="image-20210418124102213"></p>
<p>0和1的相加，这是巧合吗？</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418124155004.png" alt="image-20210418124155004"></p>
<p><strong>point+point等于两点的中点</strong></p>
<h2 id="affine-transformations（仿射变换）"><a href="#affine-transformations（仿射变换）" class="headerlink" title="affine transformations（仿射变换）"></a>affine transformations（仿射变换）</h2><p>我们认为仿射变换是线性变换加平移</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418125255449.png" alt="image-20210418125255449"></p>
<p><strong>using homogeneous coordinate：</strong></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418125217689.png" alt="image-20210418125217689"></p>
<p>矩阵没有交换律！！！</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418130311735.png" alt="image-20210418130311735"></p>
<p>以上那些都是2d的，如果我们是3d的呢？</p>
<p>下一章见！！</p>
<hr>
<p>4.18 13:06补完！！！</p>
<hr>
<h1 id="3-Transformation-Cont"><a href="#3-Transformation-Cont" class="headerlink" title="3.Transformation Cont"></a>3.Transformation Cont</h1><h2 id="3D-transformations（用矩阵表示3D变换）"><a href="#3D-transformations（用矩阵表示3D变换）" class="headerlink" title="3D transformations（用矩阵表示3D变换）"></a>3D transformations（用矩阵表示3D变换）</h2><p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418130453336.png" alt="image-20210418130453336"></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418130514450.png" alt="image-20210418130514450"></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418130917422.png" alt="image-20210418130917422"></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418130931816.png" alt="image-20210418130931816"></p>
<h2 id="viewing-transformation（观测变换）"><a href="#viewing-transformation（观测变换）" class="headerlink" title="viewing transformation（观测变换）"></a>viewing transformation（观测变换）</h2><h3 id="view-camera-transformation"><a href="#view-camera-transformation" class="headerlink" title="view / camera transformation"></a>view / camera transformation</h3><p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418131306574.png" alt="image-20210418131306574"></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418133930781.png" alt="image-20210418133930781"></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418133951619.png" alt="image-20210418133951619"></p>
<p>用公式表示旋转</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418134032810.png" alt="image-20210418134032810"></p>
<h2 id="projection"><a href="#projection" class="headerlink" title="projection"></a>projection</h2><p>projection</p>
<ul>
<li>orthographic projection</li>
<li>perspective projection</li>
</ul>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418135453158.png" alt="image-20210418135453158"></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418135540668.png" alt="image-20210418135540668"></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210418135637118.png" alt="image-20210418135637118"></p>
<hr>
<p>呜呜呜这话实在太水了因为实在不想写，到时候再看公式回忆吧4.18 13:58补完 </p>
<hr>
<h1 id="4-Resterization-1（Triangle）-三角形光栅化"><a href="#4-Resterization-1（Triangle）-三角形光栅化" class="headerlink" title="4.Resterization 1（Triangle） (三角形光栅化)"></a>4.Resterization 1（Triangle） (三角形光栅化)</h1><ul>
<li>Different raster displays</li>
<li>Rasterizing a triangle</li>
</ul>
<p>sometime people prefer:</p>
<p>vertical <strong>field-of-view</strong> (forY) and <strong>aspect ratio</strong> (assume symmetry i.e I=-r,b=-t)</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210412110847983.png"></p>
<p>即视锥定义需要长宽比和垂直角度</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210412113350441.png"></p>
<p>由可视角度和距离即可求屏幕大小</p>
<h2 id="what‘s-after-MVP（MVP变换）"><a href="#what‘s-after-MVP（MVP变换）" class="headerlink" title="what‘s after MVP（MVP变换）"></a>what‘s after MVP（MVP变换）</h2><ul>
<li>model transformation （placing object）</li>
<li>view transformation（placing object）</li>
<li>projection transformation（placing object）</li>
</ul>
<h2 id="canonical-cube-to-screen！（像素是屏幕上规范的正方形）"><a href="#canonical-cube-to-screen！（像素是屏幕上规范的正方形）" class="headerlink" title="canonical cube to screen！（像素是屏幕上规范的正方形）"></a>canonical cube to screen！（像素是屏幕上规范的正方形）</h2><p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210412114610510.png"></p>
<p>这里可以暂时抽象认为像素是最小单位</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210412114911212.png"></p>
<p>像素被写作（x,y），都为整数，从（0,0）开始，蓝色方块坐标为（2,1）</p>
<p>像素的指数从（0,0）到（width-1，length-1）</p>
<p>像素中心在（x+0.5，y+0.5）</p>
<p>屏幕范围为（0,0）到（width，length）</p>
<ul>
<li><p>transform in xy plane:</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210412120419388.png" alt="image-20210412120419388"></p>
<p>视口变换</p>
<p>(看不懂的滚回去看第三节！)</p>
</li>
</ul>
<p>小知识：</p>
<ul>
<li><p>隔行扫描（先偷懒扫1357…第二次扫2468….）利用了人眼的视觉暂留，提高了扫描的效率</p>
</li>
<li><p>超出人眼视网膜最大分辨率的屏幕被称为视网膜屏幕</p>
</li>
<li><p>LCD（液晶显示器）利用液晶影响光的极化</p>
</li>
<li><p>LED（发光二极管）利用阵列变成屏幕</p>
</li>
<li><p>部分电子书设备（例如kindle）利用电子墨水瓶来控制墨水的朝向</p>
</li>
</ul>
<h2 id="triangle-Fudamental-Shape-Primitives（三角形是最基本的图形）"><a href="#triangle-Fudamental-Shape-Primitives（三角形是最基本的图形）" class="headerlink" title="triangle - Fudamental Shape Primitives（三角形是最基本的图形）"></a>triangle - Fudamental Shape Primitives（三角形是最基本的图形）</h2><p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210412125303069.png" alt="image-20210412125303069"></p>
<ul>
<li>三角形是最基本的图形，所有图形能拆成三角形</li>
<li>三角形一定是平面的，有清晰严格的内外定义区分</li>
<li>只需要确定三个点，就可以三角形内部取一个点，控制它到三个点的距离得到一个渐变的过程</li>
</ul>
<h2 id="a-simple-approach：sampling（采样）"><a href="#a-simple-approach：sampling（采样）" class="headerlink" title="a simple approach：sampling（采样）"></a>a simple approach：sampling（采样）</h2><p>这里的采样是指利用像素中心对屏幕进行采样，得到每个像素的像素中心是否在图形的内</p>
<p>​                                           sample if each pixel center is inside triangle</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210412130047723.png"></p>
<p>这里我们定义inside（t，x，y）</p>
<p>{if（（x，y）在三角形t内） return 1；else return 0；}</p>
<p>rasterization==sample a 2d indicator function</p>
<p>所以，光栅化则是对2d屏幕进行采样</p>
<p>for （int x=0；x&lt;xmax;++x）</p>
<p>​    for （int y=0；x&lt;tmax;++t）</p>
<p>​           image[x] [y]=inside(tri,x+0.5,y+0.5);</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210412131049391.png"><br>白色区域不可能碰到三角形，固不考虑，只考虑三角形的包围盒（bounding box）</p>
<hr>
<p>初稿完成于2021.4.12      ！这里是分割线！</p>
<hr>
<h1 id="5-Rasterization-2（Antialiasing-and-Z-Buffering）（反走样和深度缓冲）"><a href="#5-Rasterization-2（Antialiasing-and-Z-Buffering）（反走样和深度缓冲）" class="headerlink" title="5.Rasterization 2（Antialiasing and Z-Buffering）（反走样和深度缓冲）"></a>5.Rasterization 2（Antialiasing and Z-Buffering）（反走样和深度缓冲）</h1><hr>
<p>这节课介绍反走样和深度缓冲，这节课难得多555</p>
<hr>
<p>概念：<strong>锯齿＝走样，抗锯齿=反走样</strong>（采样和走样的关系参考卖家秀和实物图，网恋和奔现）</p>
<p>视频是对时间进行采样，得到一帧帧连续的图</p>
<h2 id="problem-of-sampling（采样遇到的问题）"><a href="#problem-of-sampling（采样遇到的问题）" class="headerlink" title="problem of sampling（采样遇到的问题）"></a>problem of sampling（采样遇到的问题）</h2><ol>
<li>锯齿（Jaggies-sample in space）</li>
<li>摩尔纹（图像去掉奇数行和奇数列)(moire undersample images)</li>
<li>看到物体倒转（人眼在时间中的采样跟不上运动速度）(wagon wheel effect-sample in time)</li>
</ol>
<p>原因：信号变化太快但采样跟不上</p>
<h2 id="antialiasing-idea-is-pre-filteringbefore-sample（在采样前做滤波-模糊）"><a href="#antialiasing-idea-is-pre-filteringbefore-sample（在采样前做滤波-模糊）" class="headerlink" title="antialiasing idea is pre-filteringbefore sample（在采样前做滤波/模糊）"></a>antialiasing idea is pre-filteringbefore sample（在采样前做滤波/模糊）</h2><p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210415121726406.png"></p>
<p>先做一个模糊（滤波）然后再采样（行！）</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210415121904782.png"></p>
<p>错误示范：先采样再模糊（那岂不是更糊）（不行！）</p>
<h2 id="frequency-domain（频域）"><a href="#frequency-domain（频域）" class="headerlink" title="frequency domain（频域）"></a>frequency domain（频域）</h2><p>傅里叶奇数展开：任何周期函数都能写成正弦和余弦函数和常数项</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210415122519631.png"></p>
<p>傅里叶变换：一个函数经过某复杂变换变成另一个函数</p>
<p>逆傅里叶变换：再变回去</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210415122746904.png"></p>
<p>每隔一段时间采样，频率越高越不准确</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210415122954308.png"></p>
<p> 两种频率用同一种方法进行采样，得到的确是一样的结果，我们无法区分他们，这就称为<strong>“走样”</strong></p>
<p>模糊（滤波）：抹掉特定频域的频率（大师我悟了）</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210415123320628.png"></p>
<p>傅里叶变换把一个函数从时域（空间不同位置也算时域 ）变到频域，让我们看到图像在各个不同频域长什么样，我们称为频谱。</p>
<p>图像中心最低频，边缘最高频，图像信息的多少通过亮度来表示（例如上图的信息就主要集中在低频区域）</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210415123839901.png"></p>
<p>高通滤波（high pass filter）：把低频信息屏蔽，再逆傅里叶变换变成图像</p>
<p>如图所示高通滤波后图片剩下边界，我们认为边界是图像中变化较大的交界处</p>
<p>剧烈变化=高频信息</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210415125422894.png"></p>
<p>低通滤波（low pass filter）：把高频信息屏蔽，再逆傅里叶变换变成图像</p>
<p>如图所示边界变得模糊，因为高频信息被去掉了</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210415130033355.png"></p>
<p>如图所示是圆通滤波中通滤波申通滤波（误）</p>
<h2 id="filtering-cnvolution-（-averaging）（滤波-卷积-平均）"><a href="#filtering-cnvolution-（-averaging）（滤波-卷积-平均）" class="headerlink" title="filtering = cnvolution （=averaging）（滤波=卷积=平均）"></a>filtering = cnvolution （=averaging）（滤波=卷积=平均）</h2><p>滤波=卷积=平均？</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210415130727040.png"></p>
<p>卷积（图形学简单定义）：信号在一个地方的周围做一个平均</p>
<p>卷积定理：时域上对两个信号进行卷积相当于对他们的频域进行乘积</p>
<p>相反也适用（时域上对两个信号进行乘积相当于对他们的频域进行卷积）</p>
<p>所以我们，将图片（时域）进行傅里叶变换，得到频域，把卷积的滤波器也变到频域上，两者相乘，再逆傅里叶变换变回图像</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210415131306044.png"></p>
<p>如图所示，图像的频域和滤波器的频域相乘再逆傅里叶变换，就成功对图像进行了模糊</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210415131632230.png"></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210415131829313.png"></p>
<p>此处盒型滤波器=低通滤波器</p>
<p>若盒子变大，频域上他会变小，因为盒子越大相当于越模糊=边界越不明显=高频信息越来越少，所以频域上变小了</p>
<h2 id="sampling-repeating-frequency-contents（采样-重复频率上的内容）"><a href="#sampling-repeating-frequency-contents（采样-重复频率上的内容）" class="headerlink" title="sampling = repeating frequency contents（采样=重复频率上的内容）"></a>sampling = repeating frequency contents（采样=重复频率上的内容）</h2><p>采样=重复频率上的内容</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210415133549330.png"></p>
<p>如图所示，左边为时域右边为频域</p>
<p>这里a和c乘积=b和d的卷积，得到一堆重复的频谱</p>
<p>所以采样就是重复一个原始信号的频谱</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210415133913216.png"></p>
<p>若采样率不足/采样（复制粘贴）的速度太慢（如图所示），原始信号混叠，那这就是走样了！</p>
<h2 id="how-can-we-reduce-aliasing-error？（我们怎么减少混叠错误）"><a href="#how-can-we-reduce-aliasing-error？（我们怎么减少混叠错误）" class="headerlink" title="how can we reduce aliasing error？（我们怎么减少混叠错误）"></a>how can we reduce aliasing error？（我们怎么减少混叠错误）</h2><ol>
<li>提高显示器分辨率</li>
<li>先做模糊再做采样（反走样）（钱不够算法凑）</li>
</ol>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210415134454271.png"></p>
<p>（有没有豁然开朗的感觉呢）</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210415134700517.png"></p>
<p>如图所示以每个像素进行模糊</p>
<h2 id="antialiaing-by-supersampling（超级采样）"><a href="#antialiaing-by-supersampling（超级采样）" class="headerlink" title="antialiaing by supersampling（超级采样）"></a>antialiaing by supersampling（超级采样）</h2><p><strong>Multi sample antialiaing（MSAA）</strong></p>
<p>把一个像素划分为更小的点，判断是不是在三角形内，然后再平均起来</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210415135137603.png"></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210415135124651.png"></p>
<p>MSAA不是靠增加分辨率来直接抗锯齿的，而是靠模拟模糊得到近似三角形。</p>
<p>but not free lunch，多倍采样会造成大量的性能损耗（显卡在燃烧）</p>
<p><strong>FXAA（Fast Approximate AA）</strong></p>
<p>先把锯齿图得出，然后再进行后期处理（不是模糊），通过图像匹配找到边界，然后将其换成没有锯齿的边界，非常快速效果也不错。</p>
<p><strong>TAA（Temporal AA）</strong></p>
<p>静态时复用上一帧的结果（先不谈运动时如何使用）</p>
<p><strong>DLSS(Deep Learning Super Sampling)（老黄家RTX的招牌）</strong></p>
<p>通过深度学习把其他样本猜出来，将细节补充，从而提升分辨率</p>
<hr>
<p>本文于4.15的14:18编辑完成，这周会把前面的补上的！</p>
<hr>
<h1 id="6-Shading-1-Illumination-Shading-（照明和着色）"><a href="#6-Shading-1-Illumination-Shading-（照明和着色）" class="headerlink" title="6.Shading 1(Illumination,Shading)（照明和着色）"></a>6.Shading 1(Illumination,Shading)（照明和着色）</h1><p>小葵花妈妈课堂开课啦（误）</p>
<hr>
<h2 id="Z-Buffer（深度缓冲）"><a href="#Z-Buffer（深度缓冲）" class="headerlink" title="Z-Buffer（深度缓冲）"></a>Z-Buffer（深度缓冲）</h2><p>Visibiliy(可见性)：如何把多个物体显示在屏幕上，且位置的对应关系是对的</p>
<p><strong>画家算法：先将远的物体光栅化，如何再逐渐光栅化近的物体</strong></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210416165624059.png" alt="image-20210416165624059"></p>
<p>因为画家算法没有办法解决这种杠精问题</p>
<p>所以大伙引入了Z-Buffer（深度缓冲）</p>
<p><strong>Z-Buffer（深度缓冲）：</strong></p>
<p>我们之前默认相机放在原点离-z方向看，这里假设z越小离我们越近</p>
<p>同时生成一个frame buffer和一个z buffer（维护每个像素的深度）</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210416170341440.png" alt="image-20210416170341440"><br>就像这样<br><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210416170526880.png" alt="image-20210416170526880"><br>算法如图所示<br><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210416170801400.png" alt="image-20210416170801400"><br>假设这里的R是无限大，深度小的（即离我们更近）就会把深度大的遮挡住</p>
<p>这里我们维护的对象是每一个像素</p>
<p>透明物体没办法渲染！！！！！！</p>
<hr>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>总结一下我们目前学习的内容</strong><br><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210416172537811.png" alt="image-20210416173309456"></p>
<ol>
<li>将模型变换（model）</li>
<li>将视图变换（view）</li>
<li>三维投影到屏幕（projection）</li>
<li>进行光栅化，得到采样结果（rasterization）</li>
</ol>
<p>だから</p>
<p><strong>shading（着色）他来啦！！！</strong></p>
<h2 id="shading（着色）"><a href="#shading（着色）" class="headerlink" title="shading（着色）"></a>shading（着色）</h2><p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210416173309456.png" alt="image-20210416173309456"></p>
<p>来跟我读：谢顶</p>
<p>在图形学中，我们定义着色为对不同物体使用<strong>不同材质</strong>，不同材质和光线的相互作用有不同的方法</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210416173814199.png" alt="image-20210416173814199"></p>
<p>我们可以看到高光（specular highlight），漫反射（Diffuse reflection），环境光（ambient lighting）</p>
<h2 id="diffuse-reflection-in-Blinn-Phong-Reflectance-Model（布林冯中的漫反射）"><a href="#diffuse-reflection-in-Blinn-Phong-Reflectance-Model（布林冯中的漫反射）" class="headerlink" title="diffuse reflection in Blinn-Phong Reflectance Model（布林冯中的漫反射）"></a>diffuse reflection in Blinn-Phong Reflectance Model（布林冯中的漫反射）</h2><p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210416174102298.png" alt="image-20210416174102298"></p>
<p>我们<strong>再</strong>来做一些定义：</p>
<p>shading point：考虑一个点（在极小范围内的一个平面）的结果</p>
<p>surface normal（平面法线）</p>
<p>view direction（观察方向）</p>
<p>light direction（光照方向）</p>
<p>surface parameters（表面参数）：例如颜色，亮度</p>
<p>此处所有向量为单位向量</p>
<p><strong>shading！=shadow！！！！</strong></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210416182519198.png" alt="image-20210416182519198"></p>
<p>为什么同一束光打到一个点，角度不同亮度就不同呢？</p>
<p>我们假设光离散成六根光线，看得出来物体法线和光的夹角越小，物体表面受到的光就越少（看我们这里第一幅图，物体表面法线和光平行）</p>
<p>更科学的理解：光是一种能量，所以考虑收到的能量有多少</p>
<p>接下来是一个我并不想关心也不想记住推导过程的公式（请返回原视频56分处）</p>
<p>若光源强度（能量）为I，则距离光源距离r的光强度（能量）等于I/r2</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210416184055283.png" alt="image-20210416184055283"></p>
<p>我们可以算出光源到点的距离r，就可以求出点位置有多少能量，然后再和其余弦，漫反射系数，进行相乘。</p>
<p>点位置的能量：<strong>（I/r2）</strong></p>
<p>余弦是图中光照方向和法线点乘：<strong>max（0，n·l）</strong></p>
<p>（也就是图中的，加上一个0取max是因为我们讨论光的反射，若余弦小于0/角度为负数则没有任何物理意义）</p>
<p>定义漫反射系数:<strong>kd</strong></p>
<p>(若kd=1，则表示这个点完全不吸收能量，若kd=0，emm你可以认为这个点是黑洞)</p>
<p>最后就能求出<strong>ld</strong>（这个点应该表现多少光）</p>
<p>我们看到公示里面没有涉及到观测方向，所以漫反射结果和观测方向没有关系</p>
<hr>
<p>完成啦完成啦，4.16 19:00，今天是周五玩游戏去啦</p>
<hr>
<h1 id="7-Shading-1-Shading，pipeline，texture-mapping-（着色，管线，纹理映射）"><a href="#7-Shading-1-Shading，pipeline，texture-mapping-（着色，管线，纹理映射）" class="headerlink" title="7.Shading 1(Shading，pipeline，texture mapping)（着色，管线，纹理映射）"></a>7.Shading 1(Shading，pipeline，texture mapping)（着色，管线，纹理映射）</h1><h2 id="specular-highlight-in-blinn-phong-model（布林冯中的高光）"><a href="#specular-highlight-in-blinn-phong-model（布林冯中的高光）" class="headerlink" title="specular highlight in  blinn-phong model（布林冯中的高光）"></a>specular highlight in  blinn-phong model（布林冯中的高光）</h2><p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210420145528393.png" alt="image-20210420145528393"></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210420145344393.png" alt="image-20210420145344393"></p>
<p>高光相：由于镜面反射光的方向和观测方向接近</p>
<p>半程向量h=取l和v的角平分线，再做归一化</p>
<p>此处h和n（半程向量和法线）接近相当于v和r（观测方向和反射光）接近</p>
<p>真实情况依然要考虑表面的吸收率，我们在此处省略</p>
<p>用h和n的情况比较多，因为更好计算（其实我也不知道为什么更好算）</p>
<hr>
<p>为什么要有指数p？</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210420151229887.png" alt="image-20210420151229887"></p>
<p>因为单单一个余弦图像的容忍度很大，用它生成的高光也很大</p>
<p>在Blinn-Phong model中p一般采用100到200</p>
<p>展示出来就是这样哒</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210420151646275.png" alt="image-20210420151646275"></p>
<p>ks表示了其亮度，p越大高光越小</p>
<h2 id="ambient-lighting-in-Blinn-Phong-model（布林冯中的环境光）"><a href="#ambient-lighting-in-Blinn-Phong-model（布林冯中的环境光）" class="headerlink" title="ambient lighting in  Blinn-Phong model（布林冯中的环境光）"></a>ambient lighting in  Blinn-Phong model（布林冯中的环境光）</h2><p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210420151923545.png" alt="image-20210420151923545"></p>
<p>环境光不讲究光从哪进来，同时从哪看也没有关系，和法线也没有关系</p>
<p>所以近似认为环境光是一个常数（以上都是大胆的假设，因为深究特别难）</p>
<hr>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210420152129644.png" alt="image-20210420152129644"></p>
<p>总结一下Blinn-Phong model就是这样啦</p>
<p>布林冯是经验模型，并不基于真实物理光照哦</p>
<h2 id="Shading-Frequencies（着色频率）"><a href="#Shading-Frequencies（着色频率）" class="headerlink" title="Shading Frequencies（着色频率）"></a>Shading Frequencies（着色频率）</h2><p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210420153547995.png" alt="image-20210420153547995"></p>
<p>统一模型着色频率不相同会导致什么？</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210420154241558.png" alt="image-20210420154241558"></p>
<p>逐三角形着色：三角形表面就是一个平面，把三角形的法线求出（对边做一个叉积）</p>
<p>这种也叫<strong>Flat Shading</strong></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210420154535326.png" alt="image-20210420154535326"></p>
<p>逐顶点着色：每个顶点做一次着色（先不管顶点的法线怎么求），三个顶点组成三角形，其内部的颜色用插值获取</p>
<p>这种也叫<strong>Gouraud Shading</strong></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210420154834246.png" alt="image-20210420154834246"></p>
<p>逐像素着色：对前文提到的三角形内的每个像素都插值出独特的法线方向，对每个像素进行一次着色，得到相对比较好的结果</p>
<p>这种也叫Phong Shading（这和前面那个布林冯不一样！虽然都是冯发明的，但这个是着色频率）</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210420155241044.png" alt="image-20210420155241044"></p>
<p>哪一种更好呢？并无绝对</p>
<p>几何足够复杂时，使用相对简单的着色模型也能得到不错的结果</p>
<p>（不是很能理解的话具体看图，每一行都是同一种几何形体使用不同的着色模型，我们发现第三种几何形体已经很复杂了，但使用三种方法都相差无几，但使用冯着色模型会造成更大开销）</p>
<hr>
<p>历史遗留问题：我如何获得逐顶点和逐像素的法线</p>
<hr>
<p>逐顶点如下：</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210420160030815.png" alt="image-20210420160030815"></p>
<p>求一个顶点的法线，取和他关联的平面的法线的平均值（好办法）</p>
<hr>
<p>逐像素如下：</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210420160210027.png" alt="image-20210420160210027"></p>
<p>求得顶点的法线后，用重心坐标求出其中的法线过渡（记得归一化哦）</p>
<h2 id="Graphics（Real-time-Rendering）Pipeline（图形管线-实时渲染管线）"><a href="#Graphics（Real-time-Rendering）Pipeline（图形管线-实时渲染管线）" class="headerlink" title="Graphics（Real-time Rendering）Pipeline（图形管线/实时渲染管线）"></a>Graphics（Real-time Rendering）Pipeline（图形管线/实时渲染管线）</h2><p>给我着色模型！给我三维模型！给我光照条件！就能得到渲染结果！</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210420160938356.png" alt="image-20210420160938356"></p>
<p>管线：从一个真实场景到演示一份图像，中间发生了什么？</p>
<ol>
<li>输入空间中的点</li>
<li>将三维空间中的点投影到屏幕上</li>
<li>这些点形成三角形</li>
<li>光栅化（将三角形画在屏幕上）</li>
<li>三角形离散成各个像素</li>
<li>对每个像素进行着色</li>
<li>输出图像</li>
</ol>
<p>现代GPU允许我们自己编程控制像素和顶点如何进行着色，这个过程我们称为<strong>shader</strong></p>
<p>shader是每个顶点或每个像素通用的执行方法，只需要管每个顶点每个像素如何运作，而不是写循环。</p>
<p>如果我们写的是顶点的操作，则这个shader被称为vertex shader（顶点着色器）</p>
<p>如果我们写的是像素的操作，则这个shader被称为fragment/pixel shader（片段/像素着色器）</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210420162858944.png" alt="image-20210420162858944"></p>
<p>此处使用的GLSL是OpenGL的着色语言，图片中是像素着色器的一个小程序</p>
<p>接下来闫老师讲了一堆巴拉巴拉的不好总结</p>
<p>硬要总结一下的话就是“非常简单”（圈起来要考的）</p>
<p>讲了一堆硬件相关所以这里就先略过了</p>
<h2 id="texture-mapping（纹理映射）"><a href="#texture-mapping（纹理映射）" class="headerlink" title="texture mapping（纹理映射）"></a>texture mapping（纹理映射）</h2><p>引入纹理映射的基本思路：希望在物体不同位置定义不同的属性（漫反射系数或其他）</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210420170509136.png" alt="image-20210420170509136"></p>
<p>先做一个声明：任何三维物体的表面都是二维的</p>
<p>所以texture（纹理）是什么：texture就是一张（image）图</p>
<p>将这张图蒙在物体上（图上的点和物体上的点一一对应），这个过程就叫<strong>纹理映射</strong></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210420170830752.png" alt="image-20210420170830752"></p>
<p>（闫老师能不能用点阳间的图，san值狂掉）</p>
<p>怎么把空间中的三角形映射到平面上？</p>
<ol>
<li>需要艺术家（美工）做出一个模型，然后展开贴在物体上，对美工来说这是一个繁重的过程</li>
<li>给一个模型，我们将其展开为一个平面，希望三角形尽量少扭曲，这个过程很难，会是以后重要的研究方向（参数化）</li>
</ol>
<p>我们在纹理上定义一个坐标系（u，v）（uv的范围都在0到1）</p>
<p>这样就可以把任意物体的三角形映射到纹理上显示出来</p>
<p>接下来我们想知道：</p>
<p><strong>如果知道三角形对应顶点的uv，那么如何知道三角形内部对应每个点的uv</strong></p>
<p>下节课会着重介绍插值（通过三角形的三个顶点属性，在三角形内部做一个平滑的过渡）</p>
<hr>
<p>本文于4.20 17:25完成，终于明白什么是管线啦！（豁然开朗好开心）</p>
<hr>
<h1 id="shading3（texture-mapping）"><a href="#shading3（texture-mapping）" class="headerlink" title="shading3（texture mapping）"></a>shading3（texture mapping）</h1><h2 id="barycentric-coordinate-interpolation-across-triangles-（用重心坐标在三角形内做插值）"><a href="#barycentric-coordinate-interpolation-across-triangles-（用重心坐标在三角形内做插值）" class="headerlink" title="barycentric coordinate(interpolation across triangles)（用重心坐标在三角形内做插值）"></a>barycentric coordinate(interpolation across triangles)（用重心坐标在三角形内做插值）</h2><p><strong>为什么我们要做插值？</strong></p>
<p>很多操作在顶点才能操作，希望能在内部得到一个平滑过渡的值</p>
<p><strong>我们能插值什么内容？</strong></p>
<p>纹理的坐标，颜色，法线向量</p>
<p><strong>我们怎么做插值</strong></p>
<p>利用重心坐标！</p>
<h3 id="the-definition（定义）"><a href="#the-definition（定义）" class="headerlink" title="the definition（定义）"></a>the definition（定义）</h3><p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210422180822945.png" alt="image-20210422180822945"></p>
<p>重心坐标定义在一个三角形内，换一个三角形就换一套重心坐标</p>
<p>在三角形ABC形成的平面内的任意一点，都可以表示成为ABC坐标的线性组合（不需要再使用xy坐标系），其中<strong>三个系数αβγ之和为1</strong>（如果不为1那就不在三角形所在的平面内了）。这αβγ组成的坐标就是<strong>重心坐标</strong>。但其实我们只需要知道其中两个数，就能求得第三个数。</p>
<p>若这个点在三角形内，那么αβγ必须都为非负数。</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210422181631730.png" alt="image-20210422181631730"></p>
<p>所以A点自己的重心坐标就是（1,0,0）啦</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210422182918119.png" alt="image-20210422182918119"></p>
<p>这里α的取值就是他对应三角形的面积除以三角形的总面积，其他的也一样。</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210422183147101.png" alt="image-20210422183147101"></p>
<p>我们可以很快求得三角形的重心的重心坐标（Soga叫重心坐标原来如此）</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210422183458729.png" alt="image-20210422183458729"></p>
<p>简化一下（对计算机来说确实是简化了，但对我不是）就可以求得α和β具体的值（其实就是做叉乘操作）</p>
<p>这个表达式我们没有必要去记忆，因为很好算，我们只需要我们能得到这个重心坐标就行</p>
<hr>
<h3 id="how-to-use-barycentric-coordinate（使用重心坐标）"><a href="#how-to-use-barycentric-coordinate（使用重心坐标）" class="headerlink" title="how to use barycentric coordinate（使用重心坐标）"></a>how to use barycentric coordinate（使用重心坐标）</h3><p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210422183911971.png" alt="image-20210422183911971"></p>
<p>假设三个点有三个属性（位置，颜色，纹理坐标，法线，深度），就可以用重心坐标把所需要的点插值出来。</p>
<p>如果将空间中的三角形投影到屏幕，那么前后重心坐标的插值结果将不同（已经不是同一个三角形了）</p>
<p>所以我们如果拿到一个三维的三角形，那么我们就应该取他们三维空间中的坐标，然后算这个三角形的插值，然后再放进去，而不能在投影后的三角形中做</p>
<h2 id="applying-textures（应用纹理）"><a href="#applying-textures（应用纹理）" class="headerlink" title="applying textures（应用纹理）"></a>applying textures（应用纹理）</h2><p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210422185637961.png" alt="image-20210422185637961"></p>
<p>对应屏幕上任意一个采样点，我们都能算出这个点插值出来的uv（对应在三角形的位置），在纹理上查询这个点的颜色，我们可以认为纹理定义的就是这个点的漫反射系数（布林冯模型的kd）</p>
<p>，相当于就是把这张图贴在了物体上，同时这个物体也有冯shading 带来的高光。</p>
<h3 id="texture-magnification（纹理太小的情况）"><a href="#texture-magnification（纹理太小的情况）" class="headerlink" title="texture magnification（纹理太小的情况）"></a>texture magnification（纹理太小的情况）</h3><p>假设我们要刷一堵4k的墙，但我们的纹理只有256x256，纹理分辨率太小了怎么办</p>
<p><strong>bilinear interpolation（双线性插值）</strong></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210422190550137.png" alt="image-20210422190550137"></p>
<p>图中黑点为纹理，红点为我们的像素，如图所示像素并不是整数</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210422191542817.png" alt="image-20210422191542817"></p>
<p>我们找到这四个点，把红点（在四个像素内的坐标范围是0到1）线性插值出来</p>
<p>具体步骤：</p>
<p>把水平的这两对点插值出来，然后得到两个点，再把这两个点进行竖直方向的插值</p>
<p>虽然获得了不错的效果，但还不够完美</p>
<hr>
<p><strong>bicubic（双三次插值）</strong></p>
<p>取周围十六个点，做三次插值（不是线性的）</p>
<hr>
<p>所以好质量的东西往往伴随着更大的开销不是吗</p>
<h3 id="texture-magnification（纹理太大的情况）"><a href="#texture-magnification（纹理太大的情况）" class="headerlink" title="texture magnification（纹理太大的情况）"></a>texture magnification（纹理太大的情况）</h3><p>纹理太大的话</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210422192655054.png" alt="image-20210422192655054"></p>
<p>远处摩尔纹近处锯齿，走样啦！</p>
<p>那我们可以直接做抗锯齿吗？</p>
<p>当然可以，但是开销不小。</p>
<p>那我们不采样了！那就不会走样了！</p>
<p><strong>mipmap：</strong></p>
<p>允许做range query（范围查询）查到一个区域里面的平均值，算的快，但是近似值，且要求区域是正方形</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210422193925163.png" alt="image-20210422193925163"></p>
<p>拿到材质时先把对应的mipmap生成</p>
<p>多出这些图花费了1/3的空间，这样很棒不是吗</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210422211459918.png" alt="image-20210422211459918"></p>
<p>（这块有点听不明白）</p>
<p>我们知道一个点映射到纹理上是一块区域，那么我们怎么知道究竟是什么样的区域呢</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210422211632684.png" alt="image-20210422211632684"></p>
<p>假设这个像素有边上两个邻居，我们计算一下他到另外两个邻居的长度，然后取较长的那个构造一个正方形，然后这个正方形就是所求的近似区域。（但这不是重点，重点是这个正方形的查询怎么做）</p>
<p>假设原图为4x4，则我们在第二层做mipmap最终会得到一个像素，这个像素就是我们所需要的这个区域的平均值。</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210422212251655.png" alt="image-20210422212251655"></p>
<p>所以如图所示，离我们很近这里我们能看到很多细节，所以我们在比较低的层做查询。</p>
<p>离我们特别远的地方，一个像素覆盖的区域就特别大，所以我们要在特别高的层查询，那个时候一个区域才近似是一个像素。</p>
<p>然后我们发现这里的层是离散的，我们算不出1.8层那样的层是什么样的，最终成品说不定我们会看到一条缝，那我们怎么做呢？</p>
<p><strong>插值就行了！</strong></p>
<p><strong>triinear interpolation（三线性插值）</strong></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210422212740074.png" alt="image-20210422212740074"></p>
<p>先找第一层，再找第二层，把这两层做双线性插值，把这两层对应的插值算出来，然后再层与层之间再做一次插值 </p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210422213459234.png" alt="image-20210422213459234"></p>
<p>因为本身开销很小，所以游戏画面中很喜欢使用这个技术</p>
<h3 id="mipmap-limitation"><a href="#mipmap-limitation" class="headerlink" title="mipmap limitation"></a>mipmap limitation</h3><p>mipmap并不是在所有情况都能解决问题的</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210422213653125.png" alt="image-20210422213653125"></p>
<p>在远处会出现overblur（过分模糊）</p>
<p>因为三线性插值只能查询正方形区域的平均值</p>
<p>所以又有一个办法可以改进三线性插值带来的问题</p>
<p><strong>anisotropic filtering（各向异性过滤）</strong></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/image-20210422214045919.png" alt="image-20210422214045919"></p>
<p>（在游戏中大量采用）（需要三倍开销）</p>
<p>能解决一部分问题，得到更准确的结果，但对于图中这种斜着的矩形还是很难计算。</p>
<hr>
<p>好晚才写完，今天效率超级低4.22 21:45</p>
<hr>
<h1 id="8-Geometry-（introduction）（几何）"><a href="#8-Geometry-（introduction）（几何）" class="headerlink" title="8.Geometry （introduction）（几何）"></a>8.Geometry （introduction）（几何）</h1><h2 id="applications-of-texture（纹理的应用）"><a href="#applications-of-texture（纹理的应用）" class="headerlink" title="applications of texture（纹理的应用）"></a>applications of texture（纹理的应用）</h2><p>纹理本身是一张图，我们可以把纹理理解成线代GPU上内存上的一份数据，我们可以对它做快速的点查询和范围查询</p>
<p>可以做mipmap</p>
<p><strong>做environment map（环境光）</strong></p>
<p>我们假设有一个球是镜面的，那么他储存的内容就是环境光的内容，我们把这个球平面展开就组成了spherical environment map</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/Users\YZP\Desktop\blog\Futaba\source_posts\计算机图形学入门（笔记）\image-20210424021527948.png" alt="image-20210424021527948"></p>
<p>但显而易见的造成了扭曲</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/Users\YZP\Desktop\blog\Futaba\source_posts\计算机图形学入门（笔记）\image-20210424021629844.png" alt="image-20210424021629844"></p>
<p>解决方案是采用cube map，把这个球外边构造一个包围盒，然后把内容储存到球切割开的六个面。</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/Users\YZP\Desktop\blog\Futaba\source_posts\计算机图形学入门（笔记）\image-20210424021845824.png" alt="image-20210424021845824"></p>
<p>效果就是这样啦</p>
<p>两种方法本质都是一样的，都是为了描述不同方向的光照信息。</p>
<hr>
<p><strong>texture can affect shading</strong></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/Users\YZP\Desktop\blog\Futaba\source_posts\计算机图形学入门（笔记）\image-20210424022826279.png" alt="image-20210424022826279"></p>
<p>运用凹凸贴图就可以营造出球面凹凸不平的感觉，而不用使用更多三角形去构造</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/Users\YZP\Desktop\blog\Futaba\source_posts\计算机图形学入门（笔记）\image-20210424023316282.png" alt="image-20210424023316282"></p>
<p>相当于是不把几何形体变复杂的情况下，通过复杂的材质来定义相对高度，通过影响法线的变化从而影响着色结果</p>
<p>位移贴图（进化版）</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/Users\YZP\Desktop\blog\Futaba\source_posts\计算机图形学入门（笔记）\image-20210424025128955.png" alt="image-20210424025128955"></p>
<p>位移贴图真的移动了顶点</p>
<p>虽然这样效果更好，但是也有相应的代价，构造的三角形得足够细，细到顶点间隔比纹理频率还要高，这样才能跟得上纹理的变化速度。</p>
<hr>
<p>3D procedural noise + solid modeling</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/Users\YZP\Desktop\blog\Futaba\source_posts\计算机图形学入门（笔记）\image-20210424030659154.png" alt="image-20210424030659154"></p>
<p>用噪声算法算出大理石的纹理，或者是山脉的脉络之类</p>
<hr>
<p>provide precomputed shading</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/Users\YZP\Desktop\blog\Futaba\source_posts\计算机图形学入门（笔记）\image-20210424030912934.png" alt="image-20210424030912934"></p>
<p>提供提前预计算的环境光遮蔽</p>
<hr>
<p><strong>volume rendering</strong></p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/Users\YZP\Desktop\blog\Futaba\source_posts\计算机图形学入门（笔记）\image-20210424031121681.png" alt="image-20210424031121681"></p>
<p>体积渲染</p>
<hr>
<h2 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h2><p>复杂几何存在的问题：</p>
<ul>
<li>不便存储</li>
<li>不便渲染</li>
</ul>
<p>对几何做一个归类： </p>
<p><strong>implicit geometry（隐式几何）</strong></p>
<p>不给实际的点的位置，通过关系来表示位置，只要找出满足关系f（x，y，z）=0的所有点就能将几何表示出来。例如满足x2+y2+z2=1的话就能构造出三维的球面。</p>
<p>优点：判定一个点和几何的相对位置很容易，（内，外，重合）</p>
<p>缺点：从表达式很难看出几何的形状（不直观）</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/Users\YZP\Desktop\blog\Futaba\source_posts\计算机图形学入门（笔记）\image-20210426110832195.png" alt="image-20210426110832195"></p>
<p>explicit geometry（显式几何）</p>
<p>直接给出或通过参数映射（例如f（u，v）=xxxx，和隐式的不一样！）给出点的位置，以此来构造曲面。</p>
<p>优点：每个参数都写的清清楚楚</p>
<p>缺点：想判断一个点和几何的相对位置比较难（内，外，重合）</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/Users\YZP\Desktop\blog\Futaba\source_posts\计算机图形学入门（笔记）\image-20210426111159040.png" alt="image-20210426111159040"></p>
<p><strong>根据问题的不同需要来选择隐式或显式</strong></p>
<hr>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/Users\YZP\Desktop\blog\Futaba\source_posts\计算机图形学入门（笔记）\image-20210426112236949.png" alt="image-20210426112236949"></p>
<p>CSG：通过结合隐性几何进行布尔运算，将简单几何变成复杂几何</p>
<hr>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/Users\YZP\Desktop\blog\Futaba\source_posts\计算机图形学入门（笔记）\image-20210426112458552.png" alt="image-20210426112458552"></p>
<p>距离函数：空间中一个点到需要的几何形体的距离（可以是正的也可以是负的）</p>
<p>因为距离函数f（x）=0的时候，得到的就是物体表面</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/Users\YZP\Desktop\blog\Futaba\source_posts\计算机图形学入门（笔记）\image-20210426112653121.png" alt="image-20210426112653121"></p>
<p>应用距离函数：A和B如果制作一个简单blend，就会得到左边黑中间灰右边白</p>
<p>而我们将A和B各自做一个有向距离函数（scene distance function），然后将SDF（A）和SDF（B）做一个blend，得到的就是左边黑右边白的结果（我们需要的）</p>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/Users\YZP\Desktop\blog\Futaba\source_posts\计算机图形学入门（笔记）\image-20210426114323480.png" alt="image-20210426114323480"></p>
<p>所以两个几何最后得到这种结果</p>
<hr>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/Users\YZP\Desktop\blog\Futaba\source_posts\计算机图形学入门（笔记）\image-20210426114458470.png" alt="image-20210426114458470"></p>
<p>水平集的原理和距离函数有点类似，应用在地理上是等高线（在不同位置有相同的值）</p>
<hr>
<p><img src="/images/loading.jpg" data-original="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89/Users\YZP\Desktop\blog\Futaba\source_posts\计算机图形学入门（笔记）\image-20210426114814717.png" alt="image-20210426114814717"></p>
<p>fractals（分形）也叫自相似，和计算机中的递归是一个道理</p>
<p>（简单来说就是套娃）</p>
<hr>
<p>本文于4.27 13:35完成<br>接下来要换分段更新啦，不然加载太慢了读着也不方便</p>
<p>更新中~~</p>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2021 AprilNAVI&#39;s Blog | You are the best
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @AprilNAVI
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'korilin',
        admin: ['korilin'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

<script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body>

</html>