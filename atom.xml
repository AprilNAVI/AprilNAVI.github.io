<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AprilNAVI&#39;s Blog | You are the best</title>
  
  
  <link href="https://aprilnavi.github.io/atom.xml" rel="self"/>
  
  <link href="https://aprilnavi.github.io/"/>
  <updated>2022-04-14T20:37:58.983Z</updated>
  <id>https://aprilnavi.github.io/</id>
  
  <author>
    <name>AprilNAVI</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Games202 Lecture5 (Environment Mapping)</title>
    <link href="https://aprilnavi.github.io/2022/04/14/2022-04-14-Games202-Lecture5-(Environment-Mapping)/"/>
    <id>https://aprilnavi.github.io/2022/04/14/2022-04-14-Games202-Lecture5-(Environment-Mapping)/</id>
    <published>2022-04-14T02:06:58.000Z</published>
    <updated>2022-04-14T20:37:58.983Z</updated>
    
    <content type="html"><![CDATA[<p>一个月前的21日我写完了pcss的作业，满怀信心的直接猛冲第五节课</p><p>随后发现自己对于pbr理论还有brdf的理解已经忘光光了，听这节课就像听天书</p><p>于是用了半个多月补了pbr的理论，做了一个pbr的渲染器和一个ibl的场景</p><p>这次轮到我拿下202的ibl啦</p><span id="more"></span><h1 id="Distance-field-soft-shadow-and-SDF"><a href="#Distance-field-soft-shadow-and-SDF" class="headerlink" title="Distance field soft shadow and SDF"></a>Distance field soft shadow and SDF</h1><p>DFS有很不错的效率，速度比传统的shadow map要快，也没有SM中<strong>自遮挡和悬浮</strong>的问题</p><p>因为它的实现完全不同于之前提到的shadow map。但是no free lunch，缺点是需要大<strong>量的存储</strong>。</p><p><img src="/images/loading.jpg" data-original="/2022/04/14/2022-04-14-Games202-Lecture5-(Environment-Mapping)/image-20220414171957924.png" alt="image-20220414171957924"></p><p>效果比对如上，DFS看起来是相当棒的</p><hr><p>这里的SDF指的是某个点到达物体表面的<strong>最短距离</strong></p><p><img src="/images/loading.jpg" data-original="/2022/04/14/2022-04-14-Games202-Lecture5-(Environment-Mapping)/image-20220414175724579.png" alt="image-20220414175724579"></p><p>如图所示上图是直接将颜色进行插值的结果，但我们并不想要这种结果，我想要得到一个在中间的边界</p><p>因此我们就获取两个图像的SDF，并将其进行插值，最后就能得到我们所需要的中间的边界，同时这也能反应阴影的移动</p><p>SDF的好处是可以表示好物体的边界，可以做<strong>任意形状的Blending</strong></p><hr><p><strong>SDF Usage 1 RAY Marching</strong>（sphere tracing）</p><p><img src="/images/loading.jpg" data-original="/2022/04/14/2022-04-14-Games202-Lecture5-(Environment-Mapping)/image-20220414180250039.png" alt="image-20220414180250039"></p><p>已知整个场景的sdf，在任意一点我都可以算出一个<strong>安全距离</strong>（就例如光标的那一点）</p><p>因为那一点的sdf指的是到达场景内最近的物体的距离，因此我们就可以得出一个安全距离</p><p>在这个安全距离之内不会有其他的任何物体存在（碰不到任何物体）</p><p>假如我们有这么一根光线，我们就可以让光线每次按着他的安全距离前进，然后每次再重新前进新的安全距离</p><p>直到我已经trace了很远的距离或者sdf已经小到了某种程度</p><p>SDF若要在三维场景生成，则需要比较大的存储（毕竟空间中每个点都要储存一个sdf）</p><p>SDF可以比较好的支持<strong>运动的刚体</strong>（得是刚体哦，这也是sdf的好处），但是对于<strong>形变的物体</strong>得重新生成sdf</p><hr><p><strong>SDF Usage 2 Soft Shadow</strong></p><p>这样生成的软阴影实际上是不准的，但是效果是不错的看上去也不违和</p><p><img src="/images/loading.jpg" data-original="/2022/04/14/2022-04-14-Games202-Lecture5-(Environment-Mapping)/image-20220414182509470.png" alt="image-20220414182509470"></p><p>我们把之前所说的没一点的安全距离往前推一步，得到一个<strong>安全角度</strong></p><p>这个安全角度越小，则意味着能看到的东西越少，那么这个点的阴影就该<strong>越黑</strong></p><p>（我们可以想象如果这个点安全角度很大，这意味着我们看光源基本上没什么遮挡，可见性接近1）</p><p><img src="/images/loading.jpg" data-original="/2022/04/14/2022-04-14-Games202-Lecture5-(Environment-Mapping)/image-20220414183056119.png" alt="image-20220414183056119"></p><p>那么我们怎么求这个点的安全角度呢，我们可以用ray Marching的方法求出每步的安全距离和安全角度</p><p>去其中安全角度的最小值就是我们最终所需要的安全角度，按照这个安全角度我们转化成阴影的软硬程度</p><p>但其中所需要用到arcsin是我们希望尽量避免的（计算量大），因此有大佬优化了这个计算（其中p-o是长度）</p><p><img src="/images/loading.jpg" data-original="/2022/04/14/2022-04-14-Games202-Lecture5-(Environment-Mapping)/image-20220414184129846.png" alt="image-20220414184129846"></p><p>完全可以用sdf的值除以走过的距离，这样依然可以表示这个安全角度的大小，而不需要求出准确的角度</p><p>然后我们乘以一个系数k，再和1做一个min（因为我们不希望visibility超过1）</p><p>这个k反应了最终visibility对于安全距离的<strong>敏感程度</strong>，<strong>k越大则最后越敏感</strong></p><p>若k为100，为了保证最终区间为（0,1），sdf/p-o的区间就为（0,0.01），则0.01的变化都能引起visibility从0到1</p><p>0.01的变化都能改变visibility的0和1，则证明最后的阴影是特别硬的</p><p><img src="/images/loading.jpg" data-original="/2022/04/14/2022-04-14-Games202-Lecture5-(Environment-Mapping)/image-20220414200759280.png" alt="image-20220414200759280"></p><p>sdf场最后的表现就像是描绘了物体的表面（实际上也确实如此，毕竟sdf描述了和物体表面的距离）</p><hr><p>总结一下用sdf生成的dfs的优缺点吧（有那么些绕了）</p><p><img src="/images/loading.jpg" data-original="/2022/04/14/2022-04-14-Games202-Lecture5-(Environment-Mapping)/image-20220415012626846.png" alt="image-20220415012626846"></p><p><strong>优点：</strong>用sdf生成的dfs阴影对比传统的shadow map是<strong>高质量且快速的</strong></p><p>但这种比较是不公平的，因为没有算入sdf生成的时间（我们都是假设sdf已知）</p><p><strong>缺点：</strong>需要<strong>预计算（生成sdf）</strong>，sdf需要<strong>大量的储存空间</strong>，存在<strong>走样（锯齿）问题</strong></p><p>为了解决sdf的存储问题，会用到一些空间划分的hierarchy数据结构，比如八叉树kd树，离场景中物体都很远的点自然就不需要存sdf</p><hr><p>这里闫神说的很好：实时渲染渲染从头到尾都是近似</p><p>但这些近似不会牺牲很大的质量，同时做的也很聪明，这才是我们要学习的东西</p><hr><h1 id="Shading-from-Environment-lighting"><a href="#Shading-from-Environment-lighting" class="headerlink" title="Shading from Environment lighting"></a>Shading from Environment lighting</h1><p>核心思想是用环境贴图（spherical map，cube map）来记录场景中往任意方向看所看到的的光照</p><p>这意味着所有光照都是无限远的（记得我们之前所说的pbr需要遵循基于物理的光照吗，这里就没那么pbr了）</p><p>根据我的图像来取得各个方向上光照的渲染，工业界上称为<strong>IBL（Image Based Lighting）</strong></p><p><img src="/images/loading.jpg" data-original="/2022/04/14/2022-04-14-Games202-Lecture5-(Environment-Mapping)/image-20220415014616688.png" alt="image-20220415014616688"></p><p>我要算一个点的Shading相当于就是算这个点的Lo了，理所当然是的要解渲染方程</p><p>render equation定义内，积分指的是正半球内的所有光照（即和shading point处normal点乘结果大于0的）    </p><p>所以我要根据<strong>图像上给的irradiance</strong>，对于p点正半球内的所有光照，最后<strong>到达我眼睛（Wo也就是出射方向）的radiance</strong>是什么样的</p><p>对于求解积分，我们常用的一个通用解法就是<strong>蒙特卡洛积分</strong>还有<strong>重要性采样</strong>（之前第一次听这节课讲到这里已经懵了）</p><p>这里得好好说明一下，<strong>蒙特卡洛积分就是用来求解积分用的思想，是以高效的离散方式对连续的积分求近似</strong></p><p>我当然不可能采样大量的样本数据来计算，最后来使得结果收敛近正确的值，所以我还需要一种采样方式</p><p><strong>重要性采样是我拿离散数的方式</strong>，指的是不改变统计量，只改变概率分布，可以用来降低方差，是蒙特卡洛积分的一种采样策略</p><p>但可以的话我还是希望可以避免采样，所以我们会先从避免采样的出发点来延伸</p><hr><p>我们首先搬出之前所说的近似方案：</p><p><img src="/images/loading.jpg" data-original="/2022/04/14/2022-04-14-Games202-Lecture5-(Environment-Mapping)/image-20220415022231722.png" alt="image-20220415022231722"></p><p>还记得这个公式什么时候准确吗？答案是在<strong>g（x）的support比较小</strong>或者<strong>g的值比较smooth</strong>的情况下</p><p>BRDF的式子很满足这个性质，因此我们就有了Split Sum大法</p><hr><h2 id="Pre-filtering-Lighting"><a href="#Pre-filtering-Lighting" class="headerlink" title="Pre-filtering Lighting"></a>Pre-filtering Lighting</h2><p>第一步因此我们可以做一个拆分，我们把光照的那一项拿出来：</p><p><img src="/images/loading.jpg" data-original="/2022/04/14/2022-04-14-Games202-Lecture5-(Environment-Mapping)/image-20220415022538992.png" alt="image-20220415022538992"></p><p>你可能听说过Epic Games的分割求和近似法，将镜面反射积分拆成两个独立的积分，说的就是这个Split Sum</p><p>我们先看前面那一项，实际上我们是将一个区域的所有光照积分起来，然后再做一个normalize</p><p>求和然后再除以某个数进行normalize，这样求平均的操作你能想到什么呢？没错，那就是filter，卷积！</p><p>也就是我需要将ibl的这张图进行模糊（每个点上取周围的一个范围取一个平均然后再写回这个点）</p><p>因此将light项拆出来这一步本身就定义了模糊的操作，我们称之为生成/预计算<strong>预滤波环境贴图</strong>（irradianceMap）</p><p>（课程里面没有提到这个说法，这个说法是笔者在learnOpenGL中看到的）</p><p><img src="/images/loading.jpg" data-original="/2022/04/14/2022-04-14-Games202-Lecture5-(Environment-Mapping)/image-20220415024250764.png" alt="image-20220415024250764"></p><p>我们可以提前预计算几张不同尺寸的做好模糊的图，等到需要时我再去取</p><p>比如说我想要一个半径为x的卷积，我需要在哪张图去取呢？这个时候我们就会想起mipmap的概念</p><p>即生成几张不同filter大小的图，要查询时再做三线性插值</p><p>其实最后计算时我需要多大的filter取决于微表面模型用到的一个参数粗糙度</p><p>因为<strong>随着粗糙度的增加，参与环境贴图卷积的采样向量会更分散，导致反射更模糊（微表面模型理论）</strong></p><p>最后我们对于卷积的每个粗糙度级别，我们将按顺序把模糊后的结果存储在预滤波贴图的 mipmap 中</p><p><img src="/images/loading.jpg" data-original="/2022/04/14/2022-04-14-Games202-Lecture5-(Environment-Mapping)/image-20220415025145837.png" alt="image-20220415025145837"></p><p>左边的图表示我从某个i方向看一个点，最终反射出去的是一个<strong>lobe（波瓣）</strong>区域，我根据材质的glossy roughness分布一些采样点</p><p>我想取最终的结果，相当于对这个波瓣内的这些采样点做一个平均，然后最后得到我shading point的值</p><p>而我也可以直接对于environment lighting直接都做好一个filter，在我镜面反射的那个方向取一个准确的值，最终效果是差不多的</p><p>有这么个预计算的过程，我就可以在shading的时候直接采样所需要的值，<strong>结果合理同时取值也是很效率的√</strong></p><p>多提一些课程没提到的内容，<strong>随着粗糙度的增加，lobe的大小增加；随着入射光方向不同，lobe形状会发生变化。</strong></p><p>大多数光线最终反射到一个基于半程向量向量的lobe内大部分其余的向量都被浪费掉了</p><p>采样时尽量以lobe方向选取采样向量是有意义的，这个过程称为重要性采样。</p><hr><h2 id="Pre-filtering-BRDF"><a href="#Pre-filtering-BRDF" class="headerlink" title="Pre-filtering BRDF"></a>Pre-filtering BRDF</h2><p>我们前面算完了光照的那一项，成功的避免了大量的采样，接下来我们来看看BRDF项该怎么解决</p><p><img src="/images/loading.jpg" data-original="/2022/04/14/2022-04-14-Games202-Lecture5-(Environment-Mapping)/image-20220415030411332.png" alt="image-20220415030411332"></p><p>这里我们的思想和第一步类似，我们也预生成一个类似的什么东西，但这里的预计算会麻烦一点</p><p>因为我需要考虑所有的参数所有的可能性，假如我们引入微表面的BRDF（带有菲涅尔项和NDF项）</p><p>（之前我写微表面的时候总是下意识的写成pbr，后边改过来了因为实际上微表面是pbr的前提而并非pbr）</p><p>菲涅尔项决定了物体的基础反射率（F0）和随着不同角度反射的颜色各不相同</p><p>NDF决定了微表面的不同法线分布（可以理解成是和roughness相关的一维函数）</p><p>这样一来我们的参数有F0（菲涅尔项），roughness，Wo等变量，想做预计算几乎是不可能的，因此我们还得将式子继续简化</p><p>接下来比较高能不太好理解：</p><p><img src="/images/loading.jpg" data-original="/2022/04/14/2022-04-14-Games202-Lecture5-(Environment-Mapping)/image-20220415034221825.png" alt="image-20220415034221825"></p><p>我们根据Schlick公式将<strong>菲涅尔项</strong>替换成右边的R0巴拉巴拉巴拉，R0指的是<strong>基础反射率</strong>（也就是平常说的F0）</p><p>而Rθ指的是θ角时的菲涅尔项，在图形学中<strong>角度（入射，出射，半角）</strong>是很容易替换的概念</p><p>你可以看看右上角那张图观察一下他们的相似程度，</p><p>别问公式为什么这样为什么能这样替换，再不行的话直接嗯记能这样子替就是了</p><p><img src="/images/loading.jpg" data-original="/2022/04/14/2022-04-14-Games202-Lecture5-(Environment-Mapping)/image-20220415035919603.png" alt="image-20220415035919603"></p><p>我们可以把菲涅尔项单独拆出来，然后用一些简单的数学原理（其实左右相加最后还是等于菲涅尔项，看不懂的话底下有一个更简单的推导）</p><p>最后这么一来我成功的将基础反射率（F0啦R0啦）拆到了积分的外面来，F0一般是一个常数，这样积分就不依赖他了</p><p>此时cook torrance式子里边的F已经消去了，brdf里面只剩下D和G，而他们都只依赖roughness和cosθ</p><p>也就是说此时我们现在剩下的参数cosθ和roughness，此时我们可以对 BRDF 方程求卷积，将其结果打印在一张表内</p><p>以cosθ和roughness为坐标轴（也就是我查询的输入）来打印出一张表（纹理），这和之前的卷积环境贴图类似</p><p>这种纹理称之为 2D 查找纹理（Look Up Texture, LUT），这张纹理被称为 BRDF 积分贴图</p><p>稍后我们会将其用于光照着色器中，以获得间接镜面反射的最终卷积结果</p><p>（如何用cosθ和roughness生成最终的卷积结果，也涉及到重要性采样，在202中没有提及）</p><p>这一步完成之后，我们同样通过预计算的方式避免了大量的采样</p><p>（因为没有用到采样大量数据，因此也没有噪声，得出来的结果还相当的不错，可能这就是为什么unreal的pbr做的这么叼了）</p><p>也可以看这个learnOpenGL中给出的具体推导过程（虽然更简短但是我感觉其实看着很易懂而且不劝退）：</p><p><img src="/images/loading.jpg" data-original="/2022/04/14/2022-04-14-Games202-Lecture5-(Environment-Mapping)/image-20220415034341690.png" alt="image-20220415034341690"></p><hr><p>瞄了一眼下节课虽然标题依然还是Environment Mapping，但实际上已经在讲PRT（precomputed radiance transfer）了</p><p>所以202的ibl部分应该到这里就完结了，感觉内容其实并不是那么的全，不过讲的真的很棒</p><p>现在是4/15的4:35，明天就可以开整ibl的作业啦</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个月前的21日我写完了pcss的作业，满怀信心的直接猛冲第五节课&lt;/p&gt;
&lt;p&gt;随后发现自己对于pbr理论还有brdf的理解已经忘光光了，听这节课就像听天书&lt;/p&gt;
&lt;p&gt;于是用了半个多月补了pbr的理论，做了一个pbr的渲染器和一个ibl的场景&lt;/p&gt;
&lt;p&gt;这次轮到我拿下202的ibl啦&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>从零开始的PBR渲染</title>
    <link href="https://aprilnavi.github.io/2022/04/13/2022-04-13-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84PBR%E5%92%8CIBL%E6%B8%B2%E6%9F%93/"/>
    <id>https://aprilnavi.github.io/2022/04/13/2022-04-13-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84PBR%E5%92%8CIBL%E6%B8%B2%E6%9F%93/</id>
    <published>2022-04-13T06:06:58.000Z</published>
    <updated>2022-04-13T14:20:40.080Z</updated>
    
    <content type="html"><![CDATA[<p>本文会梳理在LearnOpenGL学习时使用的IBL以及PBR框架和Shader，这是个很重要的知识点</p><p>在我看来，这意味着渲染知识以及一门Shader语言的入门知识到这里就已经结束了（基本渲染概念，渲染管线，brdf）</p><p>因此这也是个重要的学习节点，因此笔者在这里进行一遍知识梳理，希望可以在这里站稳脚跟</p><span id="more"></span><h1 id="聊聊一些闲话"><a href="#聊聊一些闲话" class="headerlink" title="聊聊一些闲话"></a>聊聊一些闲话</h1><p>算了算从上次发布搓布林冯的模型，已经过去了79天了，再加上一开始的时间</p><p>自己从浑然不知到入门渲染以及稍微掌握ogl做一些好玩的东西，才用了不到一百天</p><p>虽然想说进步确实还可以，没有虚度光阴，但一想到鸭鸭所说的速度快的一星期就能速通</p><p>再加上有些数学公式其实还是蛮囫囵吞枣的，有些api会用但是也不算很知道其原理（经典推导等到面试前再去刷面经吧）</p><p>所以也马马虎虎啦，但是过程中真的很开心，搓出来了不少好玩的玩具，渲染真的是好玩的东西</p><hr><p>学习进度上是这个样子，事业上虽然我很紧张也很焦虑，但是客观上来说应该也会有好的结果的</p><p>我总是愿意相信我人生的所有运气都押在了事业上，而事实上也确实如此</p><p>导师和我说我分到了我们那边投入最大的在研项目，而我实习的内容就是优化引擎和看ue源码</p><p>说实话我以为我这么菜过去可能会做些劳累的边缘活，没什么收益又花时间的那种</p><p>结果分到了类似引擎开发这样的工作，真的感觉会收益很大（不用写逻辑太开心了）</p><p>我实习的内容再加上我所学习的渲染相关的知识，或许秋招真的有机会可以试试看引擎岗</p><p>（虽然我真的很不信，但是按照前辈所说客户端可以扯到图形基本上已经爆杀了）</p><p>这样下去就算我在tx死赖一年半载的实习的话收益应该也会很大，只是从零开始的引擎研究之旅还真的很迷茫</p><p>包括跟不上进度的104还有举步维艰的渲染学习，也让我觉得紧张和焦虑</p><hr><p>好在一路上认识了不少伙伴，他们为我的学习路径提供了很多不错的意见</p><p>也陪伴我度过了很多的时光，我很感激他们，也会带着我们共同的梦想走下去</p><p>虽然前路依然布满荆棘，但好在迷雾已经散去，我会有很好的未来的，我始终这么相信</p><hr><h1 id="PBR部分"><a href="#PBR部分" class="headerlink" title="PBR部分"></a>PBR部分</h1><p><img src="/images/loading.jpg" data-original="/2022/04/13/2022-04-13-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84PBR%E5%92%8CIBL%E6%B8%B2%E6%9F%93/image-20220413150414508.png" alt="image-20220413150414508"></p><p>先康康我们的效果图，对比简单用布林冯模型渲染出来的模型，我们PBR看上去有更多的细节也更加逼真了</p><p>那是因为PBR指基于物理的渲染(Physically Based Rendering)，采用的是与物理世界更相符的计算方式和参数</p><p>美术师几乎也是直接以物理参数为依据来编写表面材质的，例如这个初号机的头就是朋友从Blender里面丢出来然后我渲出来的</p><p>要说pbr的话其实也不知道从哪说起，如果从辐射度量学那边开始的话篇幅就太大了</p><p>因此我的想法是和别人相反，打算从代码往理论上回推，然后慢慢引申出pbr多了些什么和以前有什么区别</p><hr><h2 id="PBR多了些什么"><a href="#PBR多了些什么" class="headerlink" title="PBR多了些什么"></a>PBR多了些什么</h2><p>我们来康康pbr的渲染对比以前的布林冯多了什么</p><pre><code>// build and compile shaders// -------------------------Shader ourShader(&quot;pbr.vs&quot;, &quot;pbr.fs&quot;);</code></pre><p>起码shader的部分我们依然是只用了一个shader，也就是说我们目前并没有依靠其他shader来生成什么玩意</p><p>我们的计算还有最终的表现都是在这一个shader里面完成的</p><p>再看看我们的参数都需要用到哪些吧（顶点着色器没什么变化，和往常一样）</p><pre><code>// pbr.fs#version 330 coreout vec4 FragColor;in vec2 TexCoords;in vec3 WorldPos;in vec3 Normal;// material parametersuniform sampler2D albedoMap;uniform sampler2D metallicMap;uniform sampler2D roughnessMap;//uniform sampler2D ao;// lightsuniform vec3 lightPositions[4];uniform vec3 lightColors[4];uniform vec3 camPos;const float PI = 3.14159265359;</code></pre><p>纹理坐标，世界空间的着色点坐标和法线，相机位置，这些都和往常一样区别不大</p><p>而不同的是我们多了几张用来采样的纹理参与计算，他们分别是albedo,normal,metallic,roughness,ao</p><p>而这些就是我们让渲染结果看上去更真实的关键！</p><hr><h2 id="PBR的核心理念"><a href="#PBR的核心理念" class="headerlink" title="PBR的核心理念"></a>PBR的核心理念</h2><p>在浅墨前辈梳理的PBR核心理念中</p><p>PBR遵循以下理论：</p><p><strong>微平面理论（Microfacet Theory）</strong></p><p><strong>能量守恒 （Energy Conservation）</strong></p><p><strong>基于F0建模的菲涅尔反射（Fresnel Reflection）</strong></p><p><strong>线性空间光照（Linear Space Lighting）</strong></p><p><strong>色调映射（Tone Mapping）</strong></p><p><strong>基于真实世界测量的材质参数</strong></p><p><strong>光照与材质解耦（Decoupling of Lighting and Material）</strong></p><p>这里附上原链：<a href="https://zhuanlan.zhihu.com/p/56967462">【基于物理的渲染（PBR）白皮书】（二） PBR核心理论与渲染光学原理总结 - 知乎 (zhihu.com)</a></p><p>不明白上面在说什么？没关系，我们会在代码中一步步的阐述这些理论做了什么</p><hr><h2 id="代码中是怎么处理渲染方程的"><a href="#代码中是怎么处理渲染方程的" class="headerlink" title="代码中是怎么处理渲染方程的"></a>代码中是怎么处理渲染方程的</h2><p>假设我们都知道渲染方程（这里是没加间接光的反射率方程）为何物，那么读者应该也可以理解，布林冯模型也是渲染方程的一种简化形式</p><p>（理解不了也没事你姑且认为是就行了）</p><p><img src="/images/loading.jpg" data-original="/2022/04/13/2022-04-13-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84PBR%E5%92%8CIBL%E6%B8%B2%E6%9F%93/image-20220413153200054.png" alt="image-20220413153200054"></p><p>在我的理解内，渲染方程阐述了在p点位置朝着ωo方向（出射方向，也就是我们视线方向）的光线是什么样的（颜色，强弱）</p><p>每一道入射光乘以brdf之后才是他们能为最终结果所做的贡献（乘以n⋅ωi确保我们所获取的光是直射的有效的值）</p><p>将所有的这些结果在半球上做一个积分（其实也就是把无限个光方向给合起来），就得到我们所看到的样子了</p><p><strong>能量守恒 （Energy Conservation）</strong>不就用上了吗，这个公式看起来就很合乎直觉吧</p><p>而我们的PBR就可以理解我们这里的brdf采用了微平面Cook-Torrance模型</p><p>（其实是不太严谨的，真正的pbr是包含了基于物理的材质，基于物理的光照，基于物理适配的摄像机）</p><hr><p>首先很明确的一点我们当然没法真的计算“无限“这个概念，而渲染方程中的积分，它的运算包含了半球Ω内所有入射方向上的dωi</p><p>由于渲染方程和反射率方程都没有解析解，因此我们将会用离散的方法来求得这个积分的数值解</p><pre><code>int steps = 100;float sum = 0.0f;vec3 P    = ...;vec3 Wo   = ...;vec3 N    = ...;float dW  = 1.0f / steps;for(int i = 0; i &lt; steps; ++i) &#123;    vec3 Wi = getNextIncomingLightDir(i);    sum += Fr(p, Wi, Wo) * L(p, Wi) * dot(N, Wi) * dW;&#125;</code></pre><p>不过要记住代码的dW相当于一个离散的步长，而数学上，用来计算积分的dW表示的是一个连续的符号</p><p>现在很明朗了吧，L(p, Wi)是Wi方向打到p点的光（已知），dot(N, Wi)（已知）</p><p>接下来我们要算的就只剩下brdf了</p><hr><h2 id="Cook-Torrance-BRDF做了些什么"><a href="#Cook-Torrance-BRDF做了些什么" class="headerlink" title="Cook-Torrance BRDF做了些什么"></a>Cook-Torrance BRDF做了些什么</h2><p>实际上我们的pbr渲染所做的也就是将Cook-Torrance的公式带进了shader里面</p><p>（接下来的内容几乎是照搬教程的，但是教程说的真的很好，我第一次学时就可以清晰的理解到位）</p><p>附上原链：[理论 - LearnOpenGL CN (learnopengl-cn.github.io)](<a href="https://learnopengl-cn.github.io/07">https://learnopengl-cn.github.io/07</a> PBR/01 Theory/#_4)</p><p><img src="/images/loading.jpg" data-original="/2022/04/13/2022-04-13-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84PBR%E5%92%8CIBL%E6%B8%B2%E6%9F%93/image-20220413163826664.png" alt="image-20220413163826664"></p><p>这里的kd是入射光线中<strong>被折射</strong>部分的能量所占的比率，而ks是<strong>被反射</strong>部分的比率。</p><p>BRDF的左侧表示的是漫反射部分，被称为Lambertian漫反射，这和我们之前在漫反射着色中使用的漫反射系数类似，用如下公式表示</p><p><img src="/images/loading.jpg" data-original="/2022/04/13/2022-04-13-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84PBR%E5%92%8CIBL%E6%B8%B2%E6%9F%93/image-20220413164005974.png" alt="image-20220413164005974"></p><p>c表示表面颜色（回想一下我们之前所做的采样diffuse纹理）</p><p>除以π是为了对漫反射光进行标准化，因为前面含有BRDF的积分方程是受π影响的（别问为什么你除就对了）</p><p>这个Lambertian漫反射和我们之前经常使用的漫反射其实是差不多的</p><p>之前我们是用表面法向量与光照方向向量进行点乘，然后再将结果与平面颜色相乘得到漫反射的结果</p><p>点乘依然还在，但是却不在BRDF之内，而是转变成为了Lo积分末公式末尾处的n⋅ωi了</p><hr><p>BRDF的镜面反射部分要稍微复杂一些，它的形式如下所示：</p><p><img src="/images/loading.jpg" data-original="/2022/04/13/2022-04-13-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84PBR%E5%92%8CIBL%E6%B8%B2%E6%9F%93/image-20220413164758382.png" alt="image-20220413164758382"></p><p>字母D，F与G分别代表着一种类型的函数，各个函数分别用来近似的计算出表面反射特性的一个特定部分。</p><p>他们分别是<strong>法线分布函数(Normal Distribution Function)<strong>，</strong>菲涅尔方程(Fresnel Rquation)<strong>和</strong>几何函数(Geometry Function)</strong></p><hr><h2 id="法线分布函数-Normal-Distribution-Function"><a href="#法线分布函数-Normal-Distribution-Function" class="headerlink" title="法线分布函数(Normal Distribution Function)"></a>法线分布函数(Normal Distribution Function)</h2><p>还记得我们一开始提到的<strong>微表面模型理论</strong>吗</p><p>这是一个将物体表面建模成无数微观尺度上有随机朝向的理想镜面反射的小平面（microfacet）的理论。</p><p>最终的效果是在表面上的不同点处改变微平面的法线，从而改变反射和折射的光方向。</p><p>出于着色的目的，通常会用统计方法处理这种微观几何现象，将表面视为具有微观结构法线的随机分布。</p><p>也就是表面越粗糙，反射越模糊，表面越光滑，反射越集中。（这就是为什么粗糙度是参数之一啦）</p><p>而<strong>法线分布函数D</strong>则近似的表示了与某些半程向量h取向一致的微平面的比率</p><p><img src="/images/loading.jpg" data-original="/2022/04/13/2022-04-13-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84PBR%E5%92%8CIBL%E6%B8%B2%E6%9F%93/image-20220413170335847.png" alt="image-20220413170335847"></p><p>其中参数n为法线，h为半程向量，α为粗糙度</p><p>假设我们用不同的粗糙度来渲染同一个球的话（这个时候同一个点的n和h就都是一样的，变量只有粗糙度）</p><p><img src="/images/loading.jpg" data-original="/2022/04/13/2022-04-13-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84PBR%E5%92%8CIBL%E6%B8%B2%E6%9F%93/image-20220413170522909.png" alt="image-20220413170522909"></p><p>粗糙度很低（也就是说表面很光滑）的时候，与中间向量取向一致的微平面会高度集中在一个很小的半径范围内，NDF最终会生成一个非常明亮的斑点</p><p>当表面比较粗糙的时候，微平面的取向方向会更加的随机，与h向量取向一致的微平面分布在一个大得多的半径范围内</p><p>pbr shader中的真实函数是这样的：</p><pre><code>//pbr.fsfloat DistributionGGX(vec3 N, vec3 H, float roughness)//法线分布函数D项&#123;    float a      = roughness*roughness;    float a2     = a*a;    float NdotH  = max(dot(N, H), 0.0);    float NdotH2 = NdotH*NdotH;    float nom   = a2;    float denom = (NdotH2 * (a2 - 1.0) + 1.0);    denom = PI * denom * denom;    return nom / denom;&#125;</code></pre><p>可以理解为直接将NDF套公式了，还是很好理解的</p><hr><h2 id="几何函数-Geometry-Function"><a href="#几何函数-Geometry-Function" class="headerlink" title="几何函数(Geometry Function)"></a>几何函数(<strong>G</strong>eometry Function)</h2><p>几何函数从统计学上近似的求得了微平面间相互遮蔽的比率，这种相互遮蔽会损耗光线的能量。</p><p>最后呈现出来的效果就是模型上光照被损耗，变得没有那么亮</p><p>我们将要使用的几何函数是GGX与Schlick-Beckmann近似的结合体，因此又称为Schlick-GGX：</p><p><img src="/images/loading.jpg" data-original="/2022/04/13/2022-04-13-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84PBR%E5%92%8CIBL%E6%B8%B2%E6%9F%93/image-20220413171334985.png" alt="image-20220413171334985"></p><p>在开头提到的渲染eva的工程里，shader用的是针对直接光照的k</p><p>与NDF类似，几何函数采用一个材料的粗糙度参数作为输入参数，越粗糙不平的的表面其微平面间相互遮蔽的概率就越高。</p><p>其余两个参数是法线n和光线方向v，这同样是涉及到了开始提到的微表面理论模型。</p><p>为了有效的估算几何部分，需要将观察方向（几何遮蔽(Geometry Obstruction)）和光线方向向量（几何阴影(Geometry Shadowing)）都考虑进去</p><p>我们可以使用史密斯法(Smith’s method)来把两者都纳入其中：即G(n,v,l,k)=Gsub(n,v,k)Gsub(n,l,k)</p><p><img src="/images/loading.jpg" data-original="/2022/04/13/2022-04-13-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84PBR%E5%92%8CIBL%E6%B8%B2%E6%9F%93/image-20220413171810764.png" alt="image-20220413171810764"></p><p>看看我们的shader是怎么写的：</p><pre><code>//pbr.fsfloat GeometrySchlickGGX(float NdotV, float roughness)//几何函数G项&#123;    float r = (roughness + 1.0);    float k = (r*r) / 8.0;    float nom   = NdotV;    float denom = NdotV * (1.0 - k) + k;    return nom / denom;&#125;float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)//史密斯法&#123;    float NdotV = max(dot(N, V), 0.0);    float NdotL = max(dot(N, L), 0.0);    float ggx2  = GeometrySchlickGGX(NdotV, roughness);    float ggx1  = GeometrySchlickGGX(NdotL, roughness);    return ggx1 * ggx2;&#125;</code></pre><p>同样是很好理解的套公式</p><hr><h2 id="菲涅尔方程-Fresnel-Rquation"><a href="#菲涅尔方程-Fresnel-Rquation" class="headerlink" title="菲涅尔方程(Fresnel Rquation)"></a>菲涅尔方程(Fresnel Rquation)</h2><p><strong>菲涅尔方程</strong>是用来描述光在不同折射率的介质之间的行为的方程，定义了被反射的光线对比光线被折射的部分所占的比率</p><p>公式如下：</p><p><img src="/images/loading.jpg" data-original="/2022/04/13/2022-04-13-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84PBR%E5%92%8CIBL%E6%B8%B2%E6%9F%93/image-20220413213554395.png" alt="image-20220413213554395"></p><p>在菲涅尔方程中我们拿<strong>F0（即0度角入射时的菲涅尔反射率）</strong>作为材质的<strong>基本反射率</strong>参与运算</p><p>对于一般仅有实数折射率的非金属而言，可以通过查询到的物质的折射率和上面的公式，计算出F0</p><p>而我们的机甲里边用的都是金属对吧，所以我们一般还会对基础反射率添加它的表面色彩</p><pre><code>vec3 F0 = vec3(0.04);F0      = mix(F0, albedo.rgb, metalness);</code></pre><p>因为金属表面会吸收所有折射光线而没有漫反射，所以我们也可以<strong>直接使用表面颜色纹理</strong>来作为它们的基础反射率。</p><p>其他两个参数h（半程向量）和v（这里是观察方向）我们当然是已知的</p><p>看看菲涅尔项的shader是什么样的：</p><pre><code>vec3 fresnelSchlick(float cosTheta, vec3 F0)//菲涅尔项F&#123;    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);&#125;  </code></pre><p>同样是精彩的套公式环节</p><hr><h2 id="从Cook-Torrance反射率方程回到shader"><a href="#从Cook-Torrance反射率方程回到shader" class="headerlink" title="从Cook-Torrance反射率方程回到shader"></a>从Cook-Torrance反射率方程回到shader</h2><p>对于我们的每个shading point来说，我们最终的结果是依照反射率方程来进行的</p><p><img src="/images/loading.jpg" data-original="/2022/04/13/2022-04-13-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84PBR%E5%92%8CIBL%E6%B8%B2%E6%9F%93/image-20220413214925496.png" alt="image-20220413214925496"></p><p>整体的流程是怎么做的呢？</p><pre><code>void main()&#123;    vec3 albedo     = pow(texture(albedoMap, TexCoords).rgb, vec3(2.2));    float metallic  = texture(metallicMap, TexCoords).r;    float roughness = texture(roughnessMap, TexCoords).r;    float ao        = texture(aoMap, TexCoords).r;        vec3 N = normalize(Normal); //法线    vec3 V = normalize(camPos - WorldPos);//观察方向        vec3 F0 = vec3(0.04);     F0      = mix(F0, albedo, metallic);&#125;</code></pre><p>我们先将所需要的数据进行采样，同时预计算出了F0以及其他我们所需要的向量的值。</p><pre><code>    vec3 Lo = vec3(0.0);    for(int i = 0; i &lt; 4; ++i)     &#123;        vec3 L = normalize(lightPositions[i] - WorldPos);//入射光        vec3 H = normalize(V + L);//半程向量        float distance    = length(lightPositions[i] - WorldPos);        float attenuation = 1.0 / (distance * distance);        vec3 radiance     = lightColors[i] * attenuation;         vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);        float NDF = DistributionGGX(N, H, roughness);               float G   = GeometrySmith(N, V, L, roughness);          vec3 nominator    = NDF * G * F;//cook torrance的分子        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001;         vec3 specular     = nominator / denominator;          vec3 kS = F;//镜面反射系数等于菲涅尔项        vec3 kD = vec3(1.0) - kS;        kD *= 1.0 - metallic;          float NdotL = max(dot(N, L), 0.0);         Lo += (kD * albedo / PI + specular) * radiance * NdotL;    &#125;</code></pre><p>我们在场景中的不同位置放置了四个点光源，他们都参与运算并且最后将贡献相加，对于不同的光源来说他们的入射光和半程向量当然是不同的</p><p>接着我们会计算点光源的和shading point的距离，根据衰减公式算出他们最终的radiance（也就是原公式中的Li(p,ωi)）</p><p>这也诠释了PBR中基于物理的光照理念（我们的衰减不一定准确，但一定要体现这点）</p><p>因为菲涅尔方程直接给出了kS， 因此可以直接使用F表示kS（镜面反射在所有打在物体表面上的光线的贡献）</p><p>接着剩下的所有部分就都是精准的套公式了（注意我们在分母项中加了一个0.001为了避免出现除零错误）</p><p>这样所求得的最终的结果Lo（<strong>出射光线的Radiance</strong>）实际上已经是反射率方程的在半球领域Ω的积分的结果了</p><p>因为在这个简单场景中我们只有四个点光源参与真正的运算，只有它们四个入射光线会影响最终的着色</p><pre><code>vec3 ambient = vec3(0.03) * albedo * ao;vec3 color   = ambient + Lo;  </code></pre><p>剩下的工作就是加一个环境光照项给Lo，乘上环境光遮蔽，然后我们就拥有了片段的最后颜色</p><p>但我们的工作依然没有做完，因为所有光照的输入都接近他们在物理上的取值，因此先采用色调映射使Lo从LDR的值映射为HDR的值</p><p>因为我们的计算都是在线性空间中计算的，所以还要进行伽马校正，这样输出的才是最终片元的值</p><pre><code>color = color / (color + vec3(1.0));color = pow(color, vec3(1.0/2.2)); FragColor = vec4(color, 1.0);</code></pre><p>在上述的计算过程中，光照和材质不存在什么依赖关系，光可以自由自在的变化和材质产生互动</p><p>这也对应了<strong>光照与材质解耦（Decoupling of Lighting and Material）</strong></p><hr><p>PBR的渲染考虑到了我们对于render equation和brdf的理解，是一个很关键的分水岭</p><p>过程中自己半抄半改网上的教程，最终也做出了自己满意的玩具渲染器</p><p>现在熟悉的敲下这些文字应该也意味着自己真正的将渲染入门啦，恭喜恭喜</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文会梳理在LearnOpenGL学习时使用的IBL以及PBR框架和Shader，这是个很重要的知识点&lt;/p&gt;
&lt;p&gt;在我看来，这意味着渲染知识以及一门Shader语言的入门知识到这里就已经结束了（基本渲染概念，渲染管线，brdf）&lt;/p&gt;
&lt;p&gt;因此这也是个重要的学习节点，因此笔者在这里进行一遍知识梳理，希望可以在这里站稳脚跟&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>第六周学习日志</title>
    <link href="https://aprilnavi.github.io/2022/03/28/2022-03-28-%E7%AC%AC%E5%85%AD%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    <id>https://aprilnavi.github.io/2022/03/28/2022-03-28-%E7%AC%AC%E5%85%AD%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</id>
    <published>2022-03-28T00:59:56.000Z</published>
    <updated>2022-03-30T13:17:18.479Z</updated>
    
    <content type="html"><![CDATA[<p>不能说有什么进展，但好在我已经渡过了焦虑危机</p><p>起码我春招再投网易的想法是寄掉了，不想给自己太大压力</p><p>现在这样很快乐，这样就好。就算未来的自己审视起这段春招，我也会觉得是有在努力的</p><p>至少我觉得赶工一两个星期并不能改变很多东西，但是会把我心态搞崩hhhh</p><span id="more"></span><h1 id="Monday"><a href="#Monday" class="headerlink" title="Monday"></a>Monday</h1><p>昨夜今日是比较难忘的一天，我通宵到了几乎早上七点才睡</p><p>原因是在一位特别特殊的友人的追问下，我向她袒露了自己的心声</p><p>也表达了我的惋惜和遗憾，毕竟保护我的朋友和不让人困扰我一直都很擅长</p><p>但昨天的自己很勇敢，面对那个问题直接就说了“有”，现在想想还是挺厉害的233333</p><p>令我没想到的是，她居然会说“身边如果有你这样的人，会好好把握的吧”，“你也是我很珍惜的人”</p><p>我哭死，完全没想到这样的回答，不过我也不会困扰对方的，把这份喜悦珍藏在心里吧</p><hr><p>今天把OpenGL往下推进一节吧，晚上104，感觉应该没什么机会看引擎架构了</p><hr><h1 id="Tuesday"><a href="#Tuesday" class="headerlink" title="Tuesday"></a>Tuesday</h1><p>摆大烂 零提升</p><h1 id="Wednesday"><a href="#Wednesday" class="headerlink" title="Wednesday"></a>Wednesday</h1><p>摆大烂 零提升 烦躁</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不能说有什么进展，但好在我已经渡过了焦虑危机&lt;/p&gt;
&lt;p&gt;起码我春招再投网易的想法是寄掉了，不想给自己太大压力&lt;/p&gt;
&lt;p&gt;现在这样很快乐，这样就好。就算未来的自己审视起这段春招，我也会觉得是有在努力的&lt;/p&gt;
&lt;p&gt;至少我觉得赶工一两个星期并不能改变很多东西，但是会把我心态搞崩hhhh&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>游戏引擎架构精要（才怪）⑤</title>
    <link href="https://aprilnavi.github.io/2022/03/21/2022-03-21-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E7%B2%BE%E8%A6%81%EF%BC%88%E6%89%8D%E6%80%AA%EF%BC%89%E2%91%A4/"/>
    <id>https://aprilnavi.github.io/2022/03/21/2022-03-21-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E7%B2%BE%E8%A6%81%EF%BC%88%E6%89%8D%E6%80%AA%EF%BC%89%E2%91%A4/</id>
    <published>2022-03-21T09:17:58.000Z</published>
    <updated>2022-03-25T12:32:48.531Z</updated>
    
    <content type="html"><![CDATA[<p>《Game Engine Architecture》是一直以来我很有兴趣也很想阅读的书，书的译者是我很敬重的milo叶劲峰前辈（魔方引擎中心的大大）。</p><p>但是由于自己基础不牢，再加上这本厚厚的大书所带来的畏难情绪，同时自己过于功利总是把时间抽去做容易提升的事情，</p><p>以及n个自己给自己找的理由，让这个阅读计划一直搁置。</p><p>但这学期拿到了暑期实习的offer，刚巧也在魔方，对于就业的压力就减小了很多</p><p>再加上自己有意往引擎方向发展，阅读这本书就提上了日程。</p><span id="more"></span><p>上次翻书还是在15号，然后上周的日志还是空的。我更加好奇上星期我都做了些什么</p><p>看到这个标题我想起很久以前看的《编程模式》里面提及的游戏循环的更新方式</p><p>即unity的Update函数和ue4中的Tick函数，不过这一章节好像不是说这些的</p><hr><h1 id="游戏循环及实时模拟"><a href="#游戏循环及实时模拟" class="headerlink" title="游戏循环及实时模拟"></a>游戏循环及实时模拟</h1><p>这一章我们会探讨时间和引擎的关系，以及在引擎中运用时间的常见方法</p><h2 id="7-1-渲染循环"><a href="#7-1-渲染循环" class="headerlink" title="7.1 渲染循环"></a>7.1 渲染循环</h2><p>在实时渲染的应用中，我们的大部分程序体都运行在渲染循环里面</p><p>渲染循环的结构一般如下,写过OpenGL应该很熟悉了：</p><pre><code>while(!quit)&#123;//更新相机，在光栅化里面我们会更新view矩阵UpdateCamera();//更新场景中所有动态元素的位置，方向，以及其他相关视觉信息UpdateSceneElements();//把静止的场景渲染到离屏的帧缓冲RenderScene()//交换帧缓冲SwapBuffers&#125;</code></pre><h2 id="7-2-游戏循环"><a href="#7-2-游戏循环" class="headerlink" title="7.2 游戏循环"></a>7.2 游戏循环</h2><p>游戏由很多种子系统组成，包括IO，渲染，动画，物理。网络同步等</p><p>其中每个子系统的循环频率可能不同，例如动画往往和渲染有着同样的刷新率</p><p>而物理可能需要更高的刷新率（可能是120hz？）而AI往往是30帧</p><p>我们先以最简单的方法来更新引擎的所有子系统，即采用单一循环</p><p>这种循环称为游戏循环，是整个游戏的主循环</p><p>底下的伪代码个人感觉和自己写的OpenGL程序也有相似之处</p><p>毕竟我们的OpenGL代码也是跑在glfw窗口库里面的嘛</p><pre><code>void Main()&#123;   Init();   While(true)  &#123;    ReadHumanInterFaceDevices();        if(QuitButtonPressed())    &#123;      break;//离开循环    &#125;        //移动手柄更新输入    //更新球的位置    //碰撞检测和球的弹射逻辑    //球是否碰壁，碰壁则加分，重置球的位置        Render();      &#125;&#125;</code></pre><hr><h2 id="7-3-游戏循环的架构风格"><a href="#7-3-游戏循环的架构风格" class="headerlink" title="7.3 游戏循环的架构风格"></a>7.3 游戏循环的架构风格</h2><p><strong>视窗消息泵：</strong></p><p>没什么卵用，鼠标移动视窗大小的话游戏会愣住不动</p><p><strong>回调框架驱动：</strong></p><p>有些引擎和中间套件以框架构成，我们只需要填补框架中空缺的自定义实现部分（或者override预设行为）</p><p>例如OGRE渲染引擎就是用OGRE框架实现，程序员需要从Ogre:FrameListener派生一个类</p><p>并Override两个虚函数FrameStart和FrameEnd，OGRE在渲染三维场景时会调用这两个虚函数</p><p>因此就可以在渲染前处理一些输入，更新相机，更新物理等工作，在帧结束时也做一些工作</p><p><strong>基于事件更新：</strong></p><p>有些游戏引擎使用事件系统来更新，游戏在实现更新时只需要加入这个事件进入队列</p><p>在处理这个事件时可以以我们想要的周期进行更新，接着这串代码会发送一个新事件进入队列</p><p>周而复始的完成游戏的周期循环</p><h2 id="7-4-抽象时间线"><a href="#7-4-抽象时间线" class="headerlink" title="7.4 抽象时间线"></a>7.4 抽象时间线</h2><p><strong>真实时间：</strong></p><p>通过CPU的高分辨率计时寄存器获取的真实的时间</p><p><strong>游戏时间：</strong></p><p>只使用一条时间线的限制很大，我们可以独立出另一条时间线。</p><p>在正常情况下这条时间线和真实时间线是一样的，但暂停游戏时可以停止这条时间线</p><p>我们此刻可以通过基于另一条正常时间线的飞行摄像机在场景中游览</p><p>为了实现慢动作，可以把这条时间线放慢，以此实现很多效果</p><p>要谨记暂停游戏时，我们的游戏循环依然在运行，只是时钟停止了</p><p><strong>局部时间：</strong></p><p>在ue里面我们播的动画，音频，timeline都是局部的时间线，很好理解</p><hr><h2 id="7-5-测量以及处理时间"><a href="#7-5-测量以及处理时间" class="headerlink" title="7.5 测量以及处理时间"></a>7.5 测量以及处理时间</h2><p>我们平时所说的帧率是屏幕一秒钟刷新的次数，通常以FPS（frame per second）来度量</p><p>可以简单理解为我们把一秒钟分成了多少个周期，恰巧我们经常以每帧为一个更新周期</p><p>两帧之间间隔的时间△t称之为时间增量，这个增量对于我们的游戏逻辑运算有着很重要的意义</p><hr><p><strong>随性能进行更新</strong></p><p>假设我们的飞船以恒定速来40m/s飞行，则飞船的速率v乘以△t，就能得到△x＝v△t，下一帧的位移x2就=x1+△x</p><p>但早期游戏开发中，并不会过于在意恒定的帧率，程序员可能完全忽略△t</p><p>因此物体的速度可能依赖于机器的帧率，而这个帧率是不稳定的。</p><p>记得我们玩过的早期宝可梦吗，按住快进按钮人物和动画音乐以及整个游戏的一切都会以数倍速度运行</p><hr><p><strong>使用固定步长更新</strong></p><p>若不希望△t与CPU的运行速度不挂钩，我们可以读取一个特定某帧的△t，存下来作为全局变量之后使用</p><p>许多引擎用的也是这种方式，但使用某次的帧率来代表接下来所有的帧率可能会带来不好的后果</p><p>例如当前帧率为30fps，即33.3ms更新一次，假如有一帧特别慢花了更久的时间，例如66.6ms</p><p>那我们下一帧就要对系统更新两次来追上刚刚错失的速率，就好比我们今天摸鱼了明天就得加倍</p><p>这样可能造成恶性循环导致下一帧变成像这一帧那么慢甚至更慢</p><hr><p><strong>使用平均帧数更新</strong></p><p>一个合理的方式是连续计算几帧所耗时的平均时间，用来估计下一帧的△t</p><p>此方法可以使游戏适应转变中的帧率。平均帧数越多，对帧率急速转变的应变能力越小，但是受影响越小</p><hr><p><strong>限制帧率</strong></p><p>我们可以将帧数限定在例如60fps，当这一帧耗时很短时，我们就让主线程休眠，直到达到休眠时间</p><p>但只有当游戏的平均帧率接近目标帧率时，此方法才有效，若经常遇到慢帧，游戏就会不断的在45到60跳动</p><p>为了应对不稳定的帧率，也得将引擎系统设计成接受任意的△t。维持稳定的帧率，对游戏很多方面都很重要</p><p>例如物理模拟中的数值积分，以固定时间运作是最好的。稳定的帧率使画面看上去也更流畅</p><hr><p><strong>画面撕裂</strong></p><p>这种现象出现在背景缓冲区和前景缓冲区交换时，显示硬件只绘制了部分屏幕，旧的部分和新的部分就衔接在了一起就造成了画面撕裂。</p><p>为了避免画面撕裂，许多渲染引擎会在交换缓冲区之前等待显示器的垂直消隐区间。</p><p>等待垂直消隐区间的行为被称为垂直同步，它也是一种调控帧率的方法。</p><p>实际上他可以限制住游戏主循环的帧率，使其必然为屏幕刷新率的倍数，若两帧之间的时间超过了1/60s</p><p>则必须等待下一次消隐区间，即该帧花了2/60s</p><hr><p>大多数操作系统都提供获取系统时间的函数，但这类函数的分辨率一般为秒</p><p>并不适合用于度量游戏中的时间，因为游戏中每一帧仅耗时数毫秒</p><p>但好在所有现代CPU都有高分辨率计时器和相应的硬件寄存器，计算启动之后经过的CPU周期数</p><p>倘若用64位的整数来储存时间，则能支持非常高的精度，但相应的空间耗费也不小</p><p>要测量高精度但较短的时间的话，32位整数也是个不错的选择</p><p>浮点数的话，只适合存储相对较短的持续时间，通常用于储存帧</p><hr><p>假如游戏在调试时遇到断点，而碰巧游戏和调试器都是在同一台机器上运行</p><p>当我们在查看断点处的代码时，时间会一直流逝，如果我们在计算平均帧率来确定时间增量</p><p>那么下一帧就会受到非常大的影响，甚至可能导致游戏崩溃，因此可以添加类似的代码段</p><pre><code>while(true)&#123;updateA();updateB();//...//估算下一帧的时间增量U64 end_ticks=readHiResTimes();dt=(F32)(begin_ticks-end_ticks)/(F32)getHiRestTimerFrequency();if(dt&gt;1.0f)&#123;dt=1.0/30.0;&#125;//把endbegin_tickS=end_ticks;&#125;</code></pre><p>有些引擎会把时间封装成一个时间类，引擎包含数个这个类的实例，用于表示真实挂钟时间</p><p>另一些用于表示游戏时间（可以暂停，可以缩放，来完成一些常见的trick）</p><hr><h2 id="7-6-多处理器的游戏循环"><a href="#7-6-多处理器的游戏循环" class="headerlink" title="7.6 多处理器的游戏循环"></a>7.6 多处理器的游戏循环</h2><p>这一内容来讨论如何让游戏运行在多核系统来取代复古的单游戏主循环去服务其多个子系统</p><p>多线程游戏的设计比单线程游戏要难得多，通常做法是让几个引擎的子系统做并行化</p><p>我们这个时候就得关注不同平台上的不同架构是怎么样的了（什么xbox360 ps3架构看着挺头晕的）</p><p>PS4上有着双总线，统一内存架构（异构统一内存架构）为程序员在灵活性和原始性能之间提供了不错的权衡</p><p>这类架构也适合大部分游戏常见的内存访问形式，即渲染数据有两种形式：</p><p>数据在CPU和GPU共享（物体变换的矩阵，光照参数，以及其他着色器参数）；数据几乎由GPU独占生产和管理；</p><p>GPU本质上是大型并行高性能微处理器集群，可以执行成百上千个并行执行的运算</p><p>我们也能利用GPU做一些非图形运算的任务，被称为GPU通用计算。</p><p>PS4上引入的比较新的异构统一内存架构是为了消除各个计算机系统各个处理中心之间的瓶颈</p><p>在此之前CPU和GPU是两个完全分离的设备，各自具有各自的内存，两者之间传输需要累赘以及高延迟的专门总线</p><hr><p>多数的现代CPU会提供单指令多数据（SIMD）指令集，这类指令能让一个运算同时执行在多个数据之上</p><p>游戏中最常用的是并行操作4个32位浮点数的指令，因为这种SIMD指令可以使三维矩阵矢量和其他矩阵运算速度提升四倍</p><hr><p>也可以采用分治然后汇合的算法，将一个单位的工作分割成更小的子任务，分配到多个线程，所有工作完成后再汇合结果</p><p>假如我们要进行动画混合，此时有五个角色，每份角色骨骼有一百个关节，我们需要处理五百对关节姿势</p><p>这五百个任务可以被切个到N个批次进行并行化，此时N的数目由可用的核心来决定</p><p>但因为每个骨骼单独计算全局姿势时，需用上他所有关节的局部姿势（有依赖关系），对单份骨骼运算只能串行计算</p><hr><p>另一个多任务方法是把子系统置于独立线程上运行，主控线程负责控制和同步这些子系统和刺激子系统</p><p>并继续处理游戏的大部分高级系统。此时的子系统一般是重复性运行且隔离度较高的，例如物理，渲染，动画，音频</p><p>多线程架构需要目标硬件平台上的线程库支持，例如win32的线程api</p><hr><p>使用多线程会带来一些问题，例如我们将物理放一个线程，渲染放一个线程，这会限制其他系统中多个处理器的利用率</p><p>若某个子系统线程未完成工作，可能就会阻塞主线程和其他线程，我们可能得将粒度再切割一点</p><p>为了充分利用并行硬件架构，另一种方式是让游戏引擎把工作分成很多细小的作业</p><p>作业可以理解为一组数据和操作该组的代码结合成对，准备就绪后就可以加入队列。</p><p>在作业模型里面，工作被拆分成细粒度的作业，可以在任何闲置的处理器中运行，可以最大化处理器的利用率</p><hr><p>为了利用多处理器硬件，我们必须小心使用异步方法（发出操作请求通常不能立刻得到结果）</p><p>而平时的同步方法是程序得到结果之后才能继续运行。许多时候可以在次帧启动异步请求，而在下一帧得到结果</p><hr><h2 id="7-7-网络游戏多人循环"><a href="#7-7-网络游戏多人循环" class="headerlink" title="7.7 网络游戏多人循环"></a>7.7 网络游戏多人循环</h2><h3 id="主从式模型-CS"><a href="#主从式模型-CS" class="headerlink" title="主从式模型 CS"></a>主从式模型 CS</h3><p>大部分逻辑运行在服务器上，服务器的代码和非网络的单人游戏很相似，多个客户端连接到服务器一起参与游戏</p><p>客户端相当于一个不智能的”渲染引擎“，拙劣的模仿服务器上发生的事情</p><p>客户端会接收输入，以控制本地的玩家角色，除此之外客户端渲染什么都由服务器告知</p><p>但这样一来延迟可能不小，因此客户端代码也得将玩家输入即时转换成屏幕上的动作，这被称为玩家预测</p><p>服务器单独运行于一台机器上，这种运行方式被称为专属服务模式（dedicated server mode）</p><p>也可以客户端机器同时运行服务器，被称为客户端于服务器之上模式（client on top of server mode）</p><h3 id="点对点模型-P2P"><a href="#点对点模型-P2P" class="headerlink" title="点对点模型 P2P"></a>点对点模型 P2P</h3><p>没啥用没啥意思，不谈</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《Game Engine Architecture》是一直以来我很有兴趣也很想阅读的书，书的译者是我很敬重的milo叶劲峰前辈（魔方引擎中心的大大）。&lt;/p&gt;
&lt;p&gt;但是由于自己基础不牢，再加上这本厚厚的大书所带来的畏难情绪，同时自己过于功利总是把时间抽去做容易提升的事情，&lt;/p&gt;
&lt;p&gt;以及n个自己给自己找的理由，让这个阅读计划一直搁置。&lt;/p&gt;
&lt;p&gt;但这学期拿到了暑期实习的offer，刚巧也在魔方，对于就业的压力就减小了很多&lt;/p&gt;
&lt;p&gt;再加上自己有意往引擎方向发展，阅读这本书就提上了日程。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Games202 Lecture4 (Shadow 2)</title>
    <link href="https://aprilnavi.github.io/2022/03/21/2022-03-15-Games202-Lecture4-(Shadow-2)/"/>
    <id>https://aprilnavi.github.io/2022/03/21/2022-03-15-Games202-Lecture4-(Shadow-2)/</id>
    <published>2022-03-21T02:06:58.000Z</published>
    <updated>2022-03-21T04:59:15.279Z</updated>
    
    <content type="html"><![CDATA[<p>呜呜呜这段时间真的太忙了，感觉自己做什么都进度缓慢</p><p>希望渲染这方面可以不要忘掉放掉吧</p><p>今天的内容是202的阴影部分，希望听完课就会做作业了555</p><p>这样做一个记录也不知道是不是有效果的，但总比什么都没留下</p><p>ps：文章是15开的，21才写完，笑死</p><span id="more"></span><h1 id="More-On-PCSS"><a href="#More-On-PCSS" class="headerlink" title="More On PCSS"></a>More On PCSS</h1><p>让我们回顾一下之前PCSS（一星期没看了我自己回顾一下）</p><p><img src="/images/loading.jpg" data-original="/2022/03/21/2022-03-15-Games202-Lecture4-(Shadow-2)/image-20220321091523016.png" alt="image-20220321091523016"></p><p>图中等号右边的算式中，以·为分界线，左边是权右边是值</p><p>我们看向值的部分，其中X被称为chi，是一个符号函数，算式的值大于0函数值就为1，小于零结果就是0</p><p>这同时也是我们阴影比较的结果，即用SM中的所有点q的depth值和场景中x的depth值比大小得到非零即一的值</p><p>随后在一个区域内对所有的值做一个卷积最后加入到结果中</p><p>所以我们很清楚的是，我们做卷积的是<strong>SM和场景Shading point深度值比较的结果</strong></p><p><img src="/images/loading.jpg" data-original="/2022/03/21/2022-03-15-Games202-Lecture4-(Shadow-2)/image-20220321092902960.png" alt="image-20220321092902960"></p><p>因此我们也能重新好好的解释为什么不是在Shadow Map上做的卷积（这个内容在之前第一章的部分有重新换了个更好的说明方式）</p><p>因为我即使对Shadow Map做了模糊最后得到的值还是非零即一的，这显然没什么意义</p><p>同时我当然也不是在图像空间上做的卷积（我在已经生成好的有锯齿的图像上做一个模糊那会让图形更糊）</p><p><img src="/images/loading.jpg" data-original="/2022/03/21/2022-03-15-Games202-Lecture4-(Shadow-2)/image-20220321094426193.png" alt="image-20220321094426193"></p><p>我们看看PCSS的完整算法步骤</p><ol><li><strong>在一个确切的区域（Blocker Search Region）计算区域内遮挡物的平均深度</strong></li><li><strong>根据这个平均距离去决定卷积域的大小</strong></li><li><strong>用这个卷积去做PCF</strong></li></ol><p>很显然第一步和第三步的开销最大，第一步得遍历区域内所有点的深度取平均，第三步遍历每个点的深度做比较</p><p>为了加速这个过程我们一般会在区域内随机取一些样本以减少计算量，这样的结果是噪声会较多</p><p>工业界的做法偏向于随机采样，对于生成的噪声多的结果在图像空间上做一个降噪处理（这是比较容易的）</p><hr><h1 id="VSSM"><a href="#VSSM" class="headerlink" title="VSSM"></a>VSSM</h1><p>为了解决PCSS这两个较慢的步骤，我们引出了VSSM（Variance Soft Shadow Mapping）的概念</p><p>PCF中percentage的意义在于，我们想知道一个区域内有多少的像素是比较成功的（即比较结果为有阴影）</p><p>通常来说我们为了知道这个百分比，会把所有像素都遍历计算一遍</p><p><img src="/images/loading.jpg" data-original="/2022/03/21/2022-03-15-Games202-Lecture4-(Shadow-2)/image-20220321101541364.png" alt="image-20220321101541364"></p><p>闫神这里打了个比方，即我想知道考试分数符合条件的同学，在班里面有多少个，我会把所有同学的成绩都看一遍</p><p>我们假如知道成绩的直方图，我们就能估算出我们所要的百分比，那如果我们再大胆一点呢？</p><p>我们直接把这个直方图视作为一个正态分布，我们甚至都不需要得知正确的直方图了</p><hr><p>为了定义一个正态分布我们需要<strong>均值</strong>（决定了中间的尖尖在什么位置）和<strong>方差</strong>（决定正态分布的胖瘦23333）</p><p><img src="/images/loading.jpg" data-original="/2022/03/21/2022-03-15-Games202-Lecture4-(Shadow-2)/image-20220321103257378.png" alt="image-20220321103257378"></p><p><strong>平均值部分：</strong></p><p>所以我们的关键思想就是， 我们想快速得知这个区域内深度的平均值是多少</p><p>一张图，区域，平均值，我们能回忆起什么？没错！Mipmap！（我第一次也没想起来，滚回去补基础吧QAQ）</p><p>但是mipmap的结果不太准，而且只能查询方形的区域，所以我们还引入了SAT的概念（Summed Area Tables）</p><p><strong>方差部分：</strong></p><p>用了一个很经典的公式，即方差=平方的期望-期望的平方，在这里期望和平均具有同等概念</p><p>期望的平方好说，我们有一个区域那就可以很快的得到这个区域的深度值的平均值</p><p>我还想快速的得到平方的期望，那怎么做呢，我们再生成一张Shadow mapping来记录信息吧</p><p>用新SM的某个像素值来记录深度值的平方（经典空间换时间）</p><p>这里提一嘴，在Opengl里面我们写入SM一般是写在一个通道里面（例如r通道）</p><p>那么我们将深度值的平方也写入另外一个通道的话，甚至不需要更多的空间（好耶）</p><hr><p>得到了均值和方差之后，我们就要来生成正态分布了，我想知道有多少深度值大于某某某</p><p><img src="/images/loading.jpg" data-original="/2022/03/21/2022-03-15-Games202-Lecture4-(Shadow-2)/image-20220321103550098.png" alt="image-20220321103550098"></p><p>PDF（概率密度函数）指的是上面那条曲线，我们想计算的则是CDF，即曲线之下的面积</p><p>怎么算曲线之下的面积捏，对于一个较为通用的高斯分布的曲线来说，我们往往会把f(x)直接打印成一张表去查询</p><p>这个f(x)被称为error function（误差函数），只有数值解没有解析解，在Cpp中用erf函数就能查到对应的值</p><p>我们依然觉得这样查这样算是件很麻烦的事情，所以我们找来了切比雪夫不等式</p><p><img src="/images/loading.jpg" data-original="/2022/03/21/2022-03-15-Games202-Lecture4-(Shadow-2)/image-20220321104834653.png" alt="image-20220321104834653"></p><p>切比雪夫不等式可以告诉我们随机变量超过某个值的概率大概是什么样的，但却不需要知道随机变量满足什么样的分布</p><p>我们只需要期望和方差就够啦，我们甚至不需要知道分布是不是一个正态分布或者其他牛鬼蛇神的函数曲线</p><p>因此就可以知道大于t的面积（概率）不会超过（小于等于）多少，而我们只需要期望和方差</p><p>另一边也很好算直接用1去减就能得到，相当于我两边都可以直接快速计算获取</p><p>看到≤号直接很理所当然的在脑海里面把他替换成了≈</p><p>因此，最后我们有了均值和方差就可以很快的计算出我们所需要的CDF（概率）</p><p>切比雪夫不等式必须得满足t在均值的右边，否则就不准了，t只对半边是管用的，但是够了</p><hr><p>PS：这就是图形学吗，一次又一次的近似得到一个蒙骗人眼的理想效果，太有趣了（Trick这个词用的很妙）</p><hr><p>最后的表现如何呢？</p><p><img src="/images/loading.jpg" data-original="/2022/03/21/2022-03-15-Games202-Lecture4-(Shadow-2)/image-20220321110328534.png" alt="image-20220321110328534"></p><ul><li>我们生成了square depth map（深度平方值map），和shadow map一起生成的</li><li>在shadow map上想去一个范围的平均，直接就能查到（借助mipmap或者sat）</li><li>想要范围内深度平方值的期望，深度平方值也是一张图我们也能很快查到</li><li>均值方差都知道我们直接就把切比雪夫不等式代入，这也是很快的</li></ul><p>我们直接就可以很快速的回答：在这个范围内有百分之几的像素深度大于shading point（不可见区域的百分比）</p><p>不需要进行额外的采样或者循环，我们的第三步就直接圆满解决了（好耶）</p><p>（提醒一下第三步做的是PCF，我们在这一步做的是给定卷积域我想知道不可见区域的百分比是多少）</p><p>但很显然，我们如果有物体或者光源移动，我们就得重新生成mipmap，但在GPU上做这些非常的快（快到可以忽略 ）</p><hr><p>记得我们在PCSS第一步做的什么吗，我们要在一个所谓“ A Certain Blocker Search Area，确切的阻挡检测区域 ” 获得<strong>遮挡物的平均深度</strong></p><p>（<strong>注意是遮挡物的平均深度哦，是深度值大于Shading Point的pixel平均深度哦，不是区域所有pixel的平均深度哦</strong>）</p><p>我用mipmap可以快速得到这整个区域的平均深度，但我怎么获得遮挡区域的平均深度呢</p><p><img src="/images/loading.jpg" data-original="/2022/03/21/2022-03-15-Games202-Lecture4-(Shadow-2)/image-20220321114259114.png" alt="image-20220321114259114"></p><p>遮挡物部分的N1/N我们用切比雪夫不等式去计算，非遮挡物的部分就（1-N1/N）</p><p>但我们依然是不知道遮挡物的深度和非遮挡物的深度捏</p><p>我们再次做出大胆假设：非遮挡物的深度都和shading point的深度一模一样（阴影照射的地方很多是平面，所以这么假设也情有可原吧）</p><p>所以已知Zavg，Zunocc，N1/N，N2/N，直接代入计算就能得到Zocc，即遮挡物的平均深度</p><p>至此，第一步我们用几乎可以忽略的额外开销直接也解决了，VSSM的所有要点到这里也就结束了</p><hr><p>VSSM包含了很多很大胆却又有那么一点河里的假设，让人直呼一声妙</p><p>VSSM可以理解为PCSS的快速版本，<strong>没有噪声，速度更快</strong></p><p>但随着现代降噪手段越来越高明，而VSSM也会出现一些不合理的结果，PCSS逐渐盖过了VSSM</p><p>但VSSM解决问题的思路是大胆而精巧的，完全值得我们学习</p><hr><h1 id="MIPMAP-and-Summed-Area-Variance-Shadow-Maps"><a href="#MIPMAP-and-Summed-Area-Variance-Shadow-Maps" class="headerlink" title="MIPMAP and  Summed-Area Variance Shadow Maps"></a>MIPMAP and  Summed-Area Variance Shadow Maps</h1><p>mipmap关键：<strong>快速，近似，方形区域的快速查询</strong></p><p>但只能做方形，而且不准确，若查询范围不是2的次方，我们还需要做三线性插值，那就更加不准确了</p><p>但我们的SAT却是绝对准的，他紧密的和前缀和结构联系在一起</p><p><img src="/images/loading.jpg" data-original="/2022/03/21/2022-03-15-Games202-Lecture4-(Shadow-2)/image-20220321120710542.png" alt="image-20220321120710542"></p><p>还记得我们要做的是范围查询吗，给定一个区域能马上获得那个区域的平均。</p><p>一维的数组花O(n)的时间做一个预处理，就能得到这个SAT</p><p>接着我们对于任意范围都能很快的获得那个区域的总和，平均值也做个除法直接呼之欲出</p><p>那么在二维上我们怎么做SAT呢</p><p><img src="/images/loading.jpg" data-original="/2022/03/21/2022-03-15-Games202-Lecture4-(Shadow-2)/image-20220321122613383.png" alt="image-20220321122613383"></p><p>我们可以生成一张表，表里面每个元素都是从左上角加到此元素的值</p><p>我们生成的每个SAT都是从左上角为起点开始的，因此我们只需要查四次表就能快速获得方形内的求和</p><p>生成这个SAT可以理解成对于每一行做一遍生成，然后也对每一列做一个生成（这部分其实有一点抽象）</p><p>生成STA的时间复杂度为O(n)，这里的n认为是个数</p><p>行与行之间的SAT生成是可以并行的，因此就可以通过GPU进行并行，但开销依然是有的</p><p>PS：SAT这方面感觉不太像适合初学者手撕的内容，感觉写VSSM直接用mipmap好一点</p><hr><h1 id="Moment-Shadow-Mapping"><a href="#Moment-Shadow-Mapping" class="headerlink" title="Moment Shadow Mapping"></a>Moment Shadow Mapping</h1><p>VSSM的问题，结果不准确，在一些情况下，阴影内有突然变白变亮的现象（Light Leaking），这是不能忍受的</p><p>为了避免VSSM中描述分布不准确的问题，Moment SM采用更高阶的矩来描述分布</p><p>矩可以简单理解为次方数，像我们的VSSM就只用了一阶矩和二阶矩</p><p><img src="/images/loading.jpg" data-original="/2022/03/21/2022-03-15-Games202-Lecture4-(Shadow-2)/image-20220321125226388.png" alt="image-20220321125226388"></p><p>Moment SM用四阶的矩刚好可以得到足够近似的分布结果</p><p>而且也对应RGBA四个通道，不太需要考虑额外的存储问题</p><p><img src="/images/loading.jpg" data-original="/2022/03/21/2022-03-15-Games202-Lecture4-(Shadow-2)/image-20220321125501665.png" alt="image-20220321125501665"></p><p>如图所示Moment SM的开销大一些，但是效果显然好了很多</p><p>具体怎么做emmmm，就不细究了。</p><hr><p>我们从这次的学习历程也能看出图形算法更迭的思路，这对于其他领域也同样适用</p><p>我们为了得到一个好的结果，开发出一个好的方案，但对于美中不足的点我们再单独去想办法改进他们</p><p>为了获取实时动态阴影我们有了Shadow map，为了这个阴影可以更软更真实更高质量我们有了PCF和PCSS</p><p>为了PCF可以计算得更快，我们又有了VSSM来改进PCSS的第一步和第三步</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;呜呜呜这段时间真的太忙了，感觉自己做什么都进度缓慢&lt;/p&gt;
&lt;p&gt;希望渲染这方面可以不要忘掉放掉吧&lt;/p&gt;
&lt;p&gt;今天的内容是202的阴影部分，希望听完课就会做作业了555&lt;/p&gt;
&lt;p&gt;这样做一个记录也不知道是不是有效果的，但总比什么都没留下&lt;/p&gt;
&lt;p&gt;ps：文章是15开的，21才写完，笑死&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>第五周学习日志</title>
    <link href="https://aprilnavi.github.io/2022/03/21/%E7%AC%AC%E4%BA%94%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    <id>https://aprilnavi.github.io/2022/03/21/%E7%AC%AC%E4%BA%94%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</id>
    <published>2022-03-21T00:59:56.000Z</published>
    <updated>2022-03-25T05:56:23.346Z</updated>
    
    <content type="html"><![CDATA[<p>上星期我的表现就更烂了（烂的好！铿锵有力掷地有声）</p><p>总体表现在3.15就开搞的202第二节（VSSM）的部分到现在都是0进度</p><p>也不知道上星期都做什么去了，卷没好好卷玩没好好玩</p><p>想准备一下网易的秋招但是感觉自己渲染水平也是实在有限（没写过path tracing不会pbr）</p><p>有人觉得我是不是对自己太过于严格了，我经常也这样问自己</p><p>但人如果什么都不舍弃的话，那也注定什么都无法得到吧，我想在这条路上和认识的大家一起走下去</p><p>有着鹅的offer在我也可以直接姑且把自己当成春招的胜利者了（如果有其他佬看到这个就给佬跪了）</p><p>而且我也乐观的觉得按照自己的进度，等到秋招的时候应该还算是蛮有竞争力的（希望别打自己脸555）</p><p>上个星期就当做是摸鱼周了，起码我过得很开心，这周要DDL拉满支棱起来了！</p><span id="more"></span><h1 id="Monday"><a href="#Monday" class="headerlink" title="Monday"></a>Monday</h1><p>上午起床就在宿舍门口做的核酸，昨天晚睡了感觉眼睛疼疼的</p><p>但写下这些的时候是九点，打算花一个上午搞定202的vssm的博客记录</p><p>有时间的话再看看202的作业代码吧，衷心希望早上的效率能靠得住</p><hr><p>事实上昨天单单202的博客我就写到了下午一两点，有在做事但是效率真的不高</p><p>后边太累了直接上床摆烂，摆到下午五点淋雨去图书馆（哦对淋雨！所以第二天不舒服了）把我的书都拿回来了</p><p>然后又补理论补到晚上，晚上搞了一晚上的引擎架构搞到八点也没能把第七章看完（慢！）</p><p>然后就一边散步一边看104搞到了九点多就摆大烂了hhh</p><p>这周五会把mini engine放出来，期待捏</p><hr><h1 id="Tuesday"><a href="#Tuesday" class="headerlink" title="Tuesday"></a>Tuesday</h1><p>上午感觉身体不太舒服，前夜打崩三熬到了四点睡到了十点半才起来</p><p>中午把202作业0做了想复习一下框架（然而我对框架还是一知半解完全没有卵用）</p><p>又把文章搬到知乎然后就去好好睡了个大觉，心情一整天蛮压抑的</p><p>下午睡到了五点起来，心情状态都好了很多，不用担心发烧了，看来是没休息好</p><hr><p>晚上开始尝试202的作业1，然后被框架（框架写挺好的主要是vsc太垃圾了）搞了波心态</p><p>好在最后至少把Shadowmapping还有PCF搞出来了，最后看到结果心情还是很好的嘿嘿</p><hr><h1 id="Wednesday"><a href="#Wednesday" class="headerlink" title="Wednesday"></a>Wednesday</h1><p>对不起，我又忘记了，我只记得我写完了PCSS（可以说是抄完）</p><p>然后不出效果，然后我就狂改改了一天最后气晕了</p><hr><h1 id="Thursday"><a href="#Thursday" class="headerlink" title="Thursday"></a>Thursday</h1><p>今天是周五（写的时候），至少让我回忆一下昨天都发生了什么</p><p>昨天睡到了中午，早上做了核酸爽喝了杯咖啡</p><p>然后抄了七八个pcss终于有一个能出效果了（破拉不堪）</p><p>发现核心算法基本上和直接写差不多，找遮挡物的平均深度然后算个比例决定卷积域大小</p><p>可能有些值传错了，但我想我是理解了（大概）</p><p>然后昨天群里的老哥说我在23届实习生里面已经爆杀了（虽然我没信）</p><p>但极大的延缓了我的焦虑，所以我睡到了晚上做了一个点光源透视（跑不动算了）</p><p>然后耍手机刷到了四五点，嘿嘿，真好</p><hr><h1 id="Friday"><a href="#Friday" class="headerlink" title="Friday"></a>Friday</h1><p>我发现自己还真是贪心啊，又想学好gameplay，又想学好render</p><p>我想碰虚幻引擎源码，想学ue渲染编程，想学ECS</p><p>想拿图形api把各种牛逼的real time render全做一遍，死了算了23333</p><p>今天pilot引擎跳票了，原因是感觉新手摸多线程和ecs感觉很吃力，所以换了传统架构</p><p>真的，他们甚至又重新用传统架构写引擎，我哭死</p><p>今天目标吧Normal Mapping做出来，然后把引擎架构第七章看完吧</p><p>然后接下来都摆大烂！</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;上星期我的表现就更烂了（烂的好！铿锵有力掷地有声）&lt;/p&gt;
&lt;p&gt;总体表现在3.15就开搞的202第二节（VSSM）的部分到现在都是0进度&lt;/p&gt;
&lt;p&gt;也不知道上星期都做什么去了，卷没好好卷玩没好好玩&lt;/p&gt;
&lt;p&gt;想准备一下网易的秋招但是感觉自己渲染水平也是实在有限（没写过path tracing不会pbr）&lt;/p&gt;
&lt;p&gt;有人觉得我是不是对自己太过于严格了，我经常也这样问自己&lt;/p&gt;
&lt;p&gt;但人如果什么都不舍弃的话，那也注定什么都无法得到吧，我想在这条路上和认识的大家一起走下去&lt;/p&gt;
&lt;p&gt;有着鹅的offer在我也可以直接姑且把自己当成春招的胜利者了（如果有其他佬看到这个就给佬跪了）&lt;/p&gt;
&lt;p&gt;而且我也乐观的觉得按照自己的进度，等到秋招的时候应该还算是蛮有竞争力的（希望别打自己脸555）&lt;/p&gt;
&lt;p&gt;上个星期就当做是摸鱼周了，起码我过得很开心，这周要DDL拉满支棱起来了！&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>游戏引擎架构精要（才怪）④</title>
    <link href="https://aprilnavi.github.io/2022/03/15/2022-03-14-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E7%B2%BE%E8%A6%81%EF%BC%88%E6%89%8D%E6%80%AA%EF%BC%89%E2%91%A3/"/>
    <id>https://aprilnavi.github.io/2022/03/15/2022-03-14-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E7%B2%BE%E8%A6%81%EF%BC%88%E6%89%8D%E6%80%AA%EF%BC%89%E2%91%A3/</id>
    <published>2022-03-14T16:17:58.000Z</published>
    <updated>2022-03-14T16:19:27.211Z</updated>
    
    <content type="html"><![CDATA[<p>《Game Engine Architecture》是一直以来我很有兴趣也很想阅读的书，书的译者是我很敬重的milo叶劲峰前辈（魔方引擎中心的大大）。</p><p>但是由于自己基础不牢，再加上这本厚厚的大书所带来的畏难情绪，同时自己过于功利总是把时间抽去做容易提升的事情，</p><p>以及n个自己给自己找的理由，让这个阅读计划一直搁置。</p><p>但这学期拿到了暑期实习的offer，刚巧也在魔方，对于就业的压力就减小了很多</p><p>再加上自己有意往引擎方向发展，阅读这本书就提上了日程。</p><span id="more"></span><p>今天进104官网看，发现引擎架构理所当然成为了这门课的官方教科书</p><p>这本书确实聊的蛮浅，但本人毕竟也才疏学浅看完这本书也需要些精力</p><p>今天晚上104就开课了，感觉自己进度好慢什么都跟不上</p><p>虽然是有点急了但是我菜的离谱也是当务之急，赶紧多肝吧</p><p>今天保底把第六章搞完，有机会的话肝肝第七章</p><hr><h1 id="资源及文件系统"><a href="#资源及文件系统" class="headerlink" title="资源及文件系统"></a>资源及文件系统</h1><p>游戏引擎必须有载入和管理多种媒体的能力，包括texture，mesh，animation，sound，collision，physics，scene</p><p>这涉及到如何同步或者异步IO（串流载入）的问题，涉及到如何跨平台编写文件系统，</p><p>涉及到如何管理runtime的资产占用的内存，涉及到怎么保存交叉引用的复合对象</p><p>（今天就只记得看了这么多了，真的很摸鱼）</p><hr><h2 id="6-1-文件系统"><a href="#6-1-文件系统" class="headerlink" title="6.1 文件系统"></a>6.1 文件系统</h2><h3 id="6-1-1-文件名和路径"><a href="#6-1-1-文件名和路径" class="headerlink" title="6.1.1 文件名和路径"></a>6.1.1 文件名和路径</h3><p>路径是描述了文件系统层次中文件或目录位置的字符串</p><p>在windows上（不讨论其他平台了），路径是一般是c:\Windows\System32这样的</p><p>路径分为绝对路径和相对路径，（有机会可以提提在UE里面导资产的事情）</p><p>在运行时寻找资产是十分费时的，最好在运气前就搜寻完所有的资产</p><p>若想开发跨平台的游戏引擎，则需要实现一个轻量化的路径处理API而非直接使用平台API</p><hr><h3 id="6-1-2-文件I-O"><a href="#6-1-2-文件I-O" class="headerlink" title="6.1.2 文件I/O"></a>6.1.2 文件I/O</h3><p>一般会建议引擎将文件IO的API封装成自己的API，</p><p>好处是可以保证所有平台上都有相同的表现，可以降低维护量同时也能满足拓展的需求</p><p>我们一般会<strong>推荐使用异步文件IO API</strong>，因为如果使用同步的IO API</p><p>那么这意味着在所有数据读取完之前程序会进入<strong>阻塞</strong>，这明显是十分蛋疼的</p><p>我们希望游戏都<strong>有串流（背后加载数据，主程序继续持续运行）</strong>的功能</p><p>说起来圣莫尼卡的《战神》就把这一块玩的很好，全程基本不会黑屏读图</p><p>为了支持串流就必须使用异步的IO API，具体伪代码详见原书p278</p><p>多数异步IO库允许主程序在请求发出一段时间后，等待IO完成才继续允许</p><p>如果需要在等待IO时做些有限的工作，则这种方式十分适用。</p><p>有些IO库允许程序员取得某些异步操作的时间估计，并设置时限</p><p>以及超出时限的安排（取消请求，通知程序，继续尝试）</p><hr><h2 id="6-2-资源管理器"><a href="#6-2-资源管理器" class="headerlink" title="6.2 资源管理器"></a>6.2 资源管理器</h2><p>游戏资源必须被妥善处理，包括离线时将资产转化为引擎适用资产的离线工具</p><p>还有在runtime时载入，卸下，以及操作资源的工具。</p><h3 id="6-2-1-离线资源管理以及工具链"><a href="#6-2-1-离线资源管理以及工具链" class="headerlink" title="6.2.1 离线资源管理以及工具链"></a>6.2.1 离线资源管理以及工具链</h3><p>资产的版本控制这方面因为没有和别人协同开发过</p><p>因此更不了解如何做好一个版本控制了，这对自己搓的玩具来说也不算大事，略过</p><p>对于大部分资产来说，游戏引擎不会使用原来的格式（就好像虚幻的uasset）</p><p>每个资产会流经资产调节管道（asset Conditioning Pipeline）</p><p>此时需要一些<strong>元数据（metadata，我悟了什么是元数据）</strong>来描述如何处理资产</p><p><strong>元数据就是描述数据的数据，例如要压缩位图使用哪一种压缩方式</strong></p><p>为了管理这些metadata以及资产，我们需要某种数据库。</p><p>数据库（也可以说是资产编辑器了）一般满足如下功能：</p><p>能处理多个资产，创建，删除，查看，修改，移动（磁盘上的位置）</p><p>交叉引用，维持交叉引用完整性，保存历史版本，多种搜索方式</p><hr><p>UE4的unreal editor就是个很棒的例子，editor几乎负责一切事物</p><p>包括元数据管理，资产创建，关卡布局，</p><p>可以在创建资产时直接看到资产在游戏世界的样子（所见即所得）</p><p>还可以在Editor中直接运行游戏，以便观察其如何在游戏中运作</p><p>同时UE的引用完整性做的也相当好（读的知识越多越感觉ue做的叼）</p><p>顽皮狗和ogre的离线资产管理方案这里就不做总结了</p><hr><p>资产调节管道也称（resource conditioning pipeline，名字不重要）</p><p>每个资产管道的始端都是原生格式的源资产，通常会经过三个处理阶段到达引擎</p><ol><li><p><strong>导出器（expoter）</strong>将原生格式的资产中的数据导出为中间格式供后续管道使用</p></li><li><p><strong>编译器（compiler）</strong>将第一阶段的数据进行小改动，例如重新压缩纹理，并非所有资产都需要重新编译</p></li><li><p><strong>链接器（linker）</strong>将多个文件结合成一个包再一起导入引擎，类比cpp的链接过程</p></li></ol><hr><h3 id="6-2-2-运行时资产管理"><a href="#6-2-2-运行时资产管理" class="headerlink" title="6.2.2 运行时资产管理"></a>6.2.2 运行时资产管理</h3><p>runtime管理的许多责任和功能都和其主要功能（载入资源到内存）有关：</p><p>确保任何时候同一份资源只有一份副本，管理资源生命周期（需要时载入不需要时卸载）</p><p>处理符合资源（多个资源组成的资源），维护引用完整性，管理资源载入后的内存</p><p>载入资源后初始化资源，提供较为统一的api，尽可能支持异步</p><p>资源文件及目录组织，一般是树状的不太关心（没啥好写的）</p><hr><p>游戏中所有资源必须有某种<strong>全局唯一标识符（GUID）</strong>常见的GUID就是资源的文件系统路径</p><p>这能很直观的反应他们硬盘上的物理路径且GUID因此不会重复</p><p>为了保证在任何时间载入内存的都只有一份副本</p><p>大部分资源管理器会使用某种形式的资源注册表记录已载入的资源</p><p>以键值对的集合（键为GUID值为指针）的方法则非常经典</p><p>资源被载入内存时限以其GUID为键，加载资源注册表字典，卸载资源时删除记录</p><p>游戏请求资源时就会用GUID寻找资源注册表，找得到就传指针</p><p>找不到就自动载入一个新的资源或者返回错误码</p><p>在runtime载入资源会对游戏的帧率造成非常大的影响，甚至是停顿</p><p>因此引擎可以采用串流（异步加载）或者是在游戏进行时完全禁止加载</p><hr><p>每个资产对生命周期有不同的要求：</p><ul><li>有些资产在游戏开始时必须被载入，驻留在内存一直到整个游戏结束，或者说其生命周期是无限的。典型例子有角色网格，材质，纹理以及核心动画，HUD，以及其他全程可以听到看到的资源</li><li>有些资产的生命周期则对应某个关卡，在玩家离开关卡时资源才被弃置（就好像ue的level资产，假设我们这里所说的关卡是一个实体而非逻辑概念的话）</li><li>有些资产的生命周期短于一个关卡的时间，例如过场动画，一小段BGM</li><li>有些资产的生命周期如很难定义，例如一些音乐和音效，因为每字节只短暂停留在内存中，这类资源通常以特定大小区块为单位载入。</li></ul><hr><p>在何时载入资源是已知的好解决的，但我们应该在何时卸载资源归还内存呢</p><p>许多资源依然会在之后的关卡继续共享，我们当然不希望将某些资源卸载后马上又加载他们</p><p>一个很好的方案就是使用引用计数（提到引用计数你应该想起智能指针类）</p><p>载入新的关卡时先遍历这些关卡所需的资源，并将其引用计数加1</p><p>然后再遍历即将卸载的资源将其引用计数减一，引用计数跌到0的就应该卸载掉。</p><hr><p>载入资源是不可避免的问题是考虑资源加载到哪一块内存，之前所述的内存分配系统通常与资源管理系统有很大的关系</p><p>要么利用已有的内存分配器设计系统资源，要么就设计内存分配器以配合资源管理所需。</p><p><strong>基于堆</strong>：若目标平台为PC，则由于操作系统支持高级的虚拟内存分配，这个方法还算勉强可以接受</p><p>但如果游戏运行在一个物理内存有限的游戏机上，只配上了最基础的虚拟内存管理器（可能还没有）</p><p>那么内存碎片就会是一个较为严重的问题，可以回顾之前所说的定期整理内存碎片的方案。</p><p><strong>基于栈：</strong>因为栈的内存分配是连续的，因此不会有内存碎片的问题。若能确保游戏是线性以及以关卡为中心</p><p>且一次内存足够容纳一整个关卡，那么就可以用这个方法。我们甚至可以用堆载入资源</p><p>标记栈的堆顶位置，每次完成关卡后都重新将栈顶指针重新指回到开始标记的位置，这样就可以迅速的释放关卡的所有资源</p><p>而且永远不会导致内存碎片</p><p><strong>基于池：</strong>在支持串流（异步加载）的游戏引擎中，一个常见分配技巧是将数据转化为同等大小的区块（chunk）。</p><p>因为chunk大小一致，因此就可以使用池分配器。但与此同时就得考虑分块的空间浪费问题</p><p>同时也要避免大型数据结构的使用，取而代之使用小于单个组块的数据结构</p><hr><p>游戏的复合资源通常包含着大量交叉引用：A引用B，B引用CD，ABCD必须同时在内存才能运行</p><p>要完整的载入复合资源，就得载入其依赖的所有资源。在Cpp中交叉引用一般以指针实现。</p><p>一个好的方式是使用GUID做交叉引用，资源管理器维护一个全局资源查找表</p><p>每次将资源对象载入内存后，都要把其指针以GUID为键加入查找表中。</p><p>当所有资源对象都载入内存后，扫描一次所有对象，将其交叉引用资源对象的GUID通过查找表换成指针</p><hr><p>有的资源在载入后还需要进行初始化，例如定义mesh的顶点和索引值，这些数据在渲染前得传送到缓存</p><p>而初始化的步骤又只能在runtime进行，包括建立顶点和索引缓冲，锁定缓冲读入缓冲以及解锁缓冲</p><p>在Cpp中许多开发者更喜欢把载入后初始化和卸载置于Init（）Destory（）这样的虚函数中</p><hr><p>肝到了0点18分，没想到这一章节感觉东西不多但是居然肝了有3k字，太难以置信了</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;《Game Engine Architecture》是一直以来我很有兴趣也很想阅读的书，书的译者是我很敬重的milo叶劲峰前辈（魔方引擎中心的大大）。&lt;/p&gt;
&lt;p&gt;但是由于自己基础不牢，再加上这本厚厚的大书所带来的畏难情绪，同时自己过于功利总是把时间抽去做容易提升的事情，&lt;/p&gt;
&lt;p&gt;以及n个自己给自己找的理由，让这个阅读计划一直搁置。&lt;/p&gt;
&lt;p&gt;但这学期拿到了暑期实习的offer，刚巧也在魔方，对于就业的压力就减小了很多&lt;/p&gt;
&lt;p&gt;再加上自己有意往引擎方向发展，阅读这本书就提上了日程。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>第四周学习日志</title>
    <link href="https://aprilnavi.github.io/2022/03/14/2022-03-14-%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    <id>https://aprilnavi.github.io/2022/03/14/2022-03-14-%E7%AC%AC%E5%9B%9B%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</id>
    <published>2022-03-14T09:17:58.000Z</published>
    <updated>2022-03-14T09:09:10.480Z</updated>
    
    <content type="html"><![CDATA[<p>这周恰逢games104开课，最近又流出了很多tx裁员的消息</p><p>压力大起来了，看来得再支棱一点了</p><span id="more"></span><hr><h1 id="Monday"><a href="#Monday" class="headerlink" title="Monday"></a>Monday</h1><p>上周周末过的挺一般的（不好不坏又好又坏）</p><p>不知为什么的就很不淡定，玩游戏的负罪感也变得比之前强了</p><p>大概周五晚上产出了一篇写PCF的博客之后就再也没动过书了</p><p>好多书没看时间根本不够用，有好多想玩的时间也不够用</p><p>再加上裁员内卷的恐慌情绪以及各路小道消息一直蔓延</p><p>一直节奏不错的我也有点乱了阵脚，一晚上都没有睡好觉</p><p>以至于今天早上抱了本书来看，结果闷头睡了一早上</p><p>十一点tx那边把我资料打回来了让我重新提交搞得我也有点怕怕的</p><hr><p>中午饱饱的睡了一觉之后压力没那么大了</p><p>但是下午一边摸鱼一边看书效率真的挺堪忧的</p><p>一想到自己UE引擎渲染三修，晚上又开104的课要听</p><p>瞬间就觉得压力好大，一堆想学一堆在学一堆没时间学</p><p>今天下午看引擎架构关于资源管理的那一章节就看了两个多小时</p><p>确实是感觉深度没有很深，看着也不痛不痒的感觉没学到什么</p><p>更大原因应该还是自己动手能力不足没法直接跟着敲一个出来</p><p>不过既然看了还是好好产出吧。</p><p>晚上争取八点前吧引擎架构的第六章和第七章搞完然后去看104！</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;这周恰逢games104开课，最近又流出了很多tx裁员的消息&lt;/p&gt;
&lt;p&gt;压力大起来了，看来得再支棱一点了&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Games202 Lecture3 (Shadow 1)</title>
    <link href="https://aprilnavi.github.io/2022/03/11/2022-03-11-Games202-Lecture3-(Shadow-1)/"/>
    <id>https://aprilnavi.github.io/2022/03/11/2022-03-11-Games202-Lecture3-(Shadow-1)/</id>
    <published>2022-03-11T02:06:58.000Z</published>
    <updated>2022-03-15T02:40:18.397Z</updated>
    
    <content type="html"><![CDATA[<p>在做opengl的时候做到了shadowmapping，效果做出来了但其实并不能算吃的很透</p><p>刚巧想起之前在202已结搭建好了框架环境，可以成功把202娘跑起来</p><p>所以会跟着202好好的把课听一遍</p><p>这次开坑的任务：</p><p>总结202课上精要内容，加入自己理解作为输出</p><p>在作业1的框架上完成shadowmapping的硬阴影</p><p>开始吧 Let ‘s go!</p><span id="more"></span><hr><h1 id="Recap-Shadow-Mapping"><a href="#Recap-Shadow-Mapping" class="headerlink" title="Recap Shadow Mapping"></a>Recap Shadow Mapping</h1><p>做两次光栅化（pass）</p><p>第一次从<strong>光的视角（light space）</strong>做一次pass，得到光看到的更近的更浅的深度值</p><p>将其渲染到一个texture上记录下来，作为ShadowMap</p><p><img src="/images/loading.jpg" data-original="/2022/03/11/2022-03-11-Games202-Lecture3-(Shadow-1)/image-20220311104355661.png" alt="image-20220311104355661"></p><p>第二次从<strong>观察视角（camera）</strong>做一次pass，得到物体更远的深度值</p><p>取一阶段的ShadowMap深度进行比较</p><p><img src="/images/loading.jpg" data-original="/2022/03/11/2022-03-11-Games202-Lecture3-(Shadow-1)/image-20220311104321858.png" alt="image-20220311104321858"></p><p>若第二次的深度值小于第一次的深度值，则生成硬阴影</p><hr><p>优势：不需要场景的几何信息，一旦shadowmap已经生成，shadowmap就能作为场景的几何表示</p><p>缺陷：会发生自遮挡和比较严重的走样（锯齿）</p><hr><p>备注：生成z值时用的矩阵如果是用正交的，第二个阶段也要拿正交的去比</p><p>同理用透视生成的z也一样，两者只要对应上都能生成正确结果</p><p>但大佬提醒，平行光用正交投影，点光源和聚光灯用透视。</p><hr><h2 id="self-occlusion"><a href="#self-occlusion" class="headerlink" title="self-occlusion"></a>self-occlusion</h2><p>如果没有在做深度对比的时候进行bias（偏移）出来的图大概率是像这样的：</p><p><img src="/images/loading.jpg" data-original="/2022/03/11/2022-03-11-Games202-Lecture3-(Shadow-1)/QQ%E5%9B%BE%E7%89%8720220311110853.jpg" alt="(QQ图片20220311110853.jpg"></p><p>原因是这样的：</p><p>我们在第一阶段用一个像素来记录深度值，但此时如果光对于平面来说是斜照的</p><p><img src="/images/loading.jpg" data-original="/2022/03/11/2022-03-11-Games202-Lecture3-(Shadow-1)/image-20220311111336669.png" alt="image-20220311111336669"></p><p>那一块区域就都只能取小红线这个深度值（即小红线就是像素记录的深度值）</p><p>当从上往下垂直照射（光线和平面法线重合）的时候，自遮挡的现象最不明显</p><p>为了尽量缩小影响bias带来的计算偏差</p><p>因此我们会根据光照和法线的夹角来计算一个bias在比较深度的时候使用：</p><pre><code>float bias = max(0.05 * (1.0 - dot(fs_in.Normal, lightDir)), 0.005);</code></pre><p>这样做也会带来一些问题，例如我们看上去物体就像浮在表面上一样</p><p>阴影并不是贴合着物体的轮廓的，我们称这种现象为悬浮(Peter Panning)</p><p>（这个概念在Learnopengl Shadowmapping有不错的解释：[阴影映射 - LearnOpenGL CN (learnopengl-cn.github.io)](<a href="https://learnopengl-cn.github.io/05">https://learnopengl-cn.github.io/05</a> Advanced Lighting/03 Shadows/01 Shadow Mapping/#_6)）</p><hr><p>RTR doesn’t trust in complexity（实时渲染不相信复杂度）就像电子竞技不相信眼泪哈哈哈</p><hr><p>晚上玩了下原神观察了下阴影，听大佬说人物的阴影用的CSM（Cascaded Shadow Mapping 级联阴影映射）</p><p>即给不同位置的shadowmap不同的分辨率，降低开销同时也能提升细节</p><p>动态阴影基本上都是用各种改进的Shadowmap做的，还有就是光追阴影</p><p>因此Shadowmap需要解决改进的就是锯齿问题</p><hr><h1 id="The-Math-Behind-Shadow-Map"><a href="#The-Math-Behind-Shadow-Map" class="headerlink" title="The Math Behind Shadow Map"></a>The Math Behind Shadow Map</h1><p><img src="/images/loading.jpg" data-original="/2022/03/11/2022-03-11-Games202-Lecture3-(Shadow-1)/image-20220311230849772.png" alt="image-20220311230849772"></p><p>将两个函数乘积再积分近似等于积分再乘积（分母相当于做归一化）</p><p>当g(x)的support（支撑集）很小,或者g(x)的函数曲线足够光滑（smooth）</p><hr><p><img src="/images/loading.jpg" data-original="/2022/03/11/2022-03-11-Games202-Lecture3-(Shadow-1)/image-20220312000423444.png" alt="image-20220312000423444"></p><p><img src="/images/loading.jpg" data-original="/2022/03/11/2022-03-11-Games202-Lecture3-(Shadow-1)/image-20220312001718439.png" alt="image-20220312001718439"></p><p>左边是visibility，右边是纯Shader的结果</p><p>对于点光源和方向光源来说，相当于是Small Support满足了第一条件</p><p>所以是可以近似认为，可以用约等式将shader和visibility的部分拆开分别计算再叠加</p><p>对于面光源来说，面光源内的radiance认为是相等各处不变的，即L是smooth的，也可以满足第一条件</p><p>而对于shading point来说diffuse的表面我们认为变化是比较小的</p><p>而glossy的表面（被打磨的铜镜之类的材质效果，是较为模糊的镜面）是较为剧变的，结果就比较不准确</p><hr><h1 id="Percentage-Closer-Soft-Shadow-PCSS"><a href="#Percentage-Closer-Soft-Shadow-PCSS" class="headerlink" title="Percentage Closer Soft Shadow (PCSS)"></a>Percentage Closer Soft Shadow (PCSS)</h1><p>对于硬阴影来说，阴影在边界上没有从无到有的过渡，看上去很不自然</p><p>在生活中，光源基本上都是理想的面光源，看到的阴影都更倾向于软阴影，有一个良好的过渡。</p><p>PCSS是用来生成软阴影的技术，建立在PCF（percentage Closer Filter）之上</p><p>PCF是起初用于解决阴影边界的抗锯齿而非计算软阴影。</p><p><strong>PCF不是对最后生成的结果的锯齿做模糊</strong>，而是在做阴影的判断时做的Filter</p><p>同样是因为不能先得到一个走样的结果，然后再做一个模糊（和做反走样的概念是一样的）</p><p><strong>PCF同样不是对生成的ShadowMap做了模糊</strong>，因为对Shadowmap和z值比较的结果也就是我们最后的</p><p>shadow值是一个非零即一的结果，即使对shadowmap做比较最后的shadow值依然是非零即一的，</p><p>这没有意义，无法达到抗锯齿的效果</p><p>PCF的做法是在投影到light space找对应像素时，不单单只找那一个像素，而是找周围一圈的像素做一个平均（Filter）</p><p>![image-20220312005309957]image-20220312005309957.png)</p><hr><p>借用learnOpenGL的对此的解释：（个人感觉很到位而且给出了具体的代码演示）</p><p>核心思想是从深度贴图中多次采样，每一次采样的纹理坐标都稍有不同。</p><p>每个独立的样本可能在也可能不再阴影中。所有的次生结果接着结合在一起，进行平均化，我们就得到了柔和阴影。</p><pre><code>float shadow = 0.0;vec2 texelSize = 1.0 / textureSize(shadowMap, 0);for(int x = -1; x &lt;= 1; ++x)&#123;    for(int y = -1; y &lt;= 1; ++y)    &#123;        float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;         shadow += currentDepth - bias &gt; pcfDepth ? 1.0 : 0.0;            &#125;    &#125;shadow /= 9.0;</code></pre><p>这个textureSize返回一个给定采样器纹理的0级mipmap的vec2类型的宽和高。</p><p>用1除以它返回一个单独纹理像素的大小，我们用以对纹理坐标进行偏移，确保每个新样本，来自不同的深度值。</p><p>这里我们采样得到9个值，它们在投影坐标的x和y值的周围，为阴影阻挡进行测试，并最终通过样本的总数目将结果平均化。</p><p>使用更多的样本，更改texelSize变量，就可以增加阴影的柔和程度。</p><p>效果可行，但对于一个shading point要做更多次的计算，所以会变得很慢</p><hr><p><img src="/images/loading.jpg" data-original="/2022/03/11/2022-03-11-Games202-Lecture3-(Shadow-1)/image-20220312010426704.png" alt="image-20220312010426704"></p><p>课程中的对比图</p><p><img src="/images/loading.jpg" data-original="/2022/03/11/2022-03-11-Games202-Lecture3-(Shadow-1)/image-20220312005843526.png" alt="image-20220312005843526"></p><p>这是自己手搓的3x3的卷积，Filter越大则阴影越软，因此软阴影就是因此计算而来的</p><p>而一般来说，离物体越近的地方阴影就越硬越明显，因此就有了Percentage Closer Soft Shadow的概念</p><p>即根据阴影与遮挡物的距离给定不同大小的filter size</p><p><img src="/images/loading.jpg" data-original="/2022/03/11/2022-03-11-Games202-Lecture3-(Shadow-1)/image-20220312020418634.png" alt="image-20220312020418634"></p><p>这张图很好的说明了Light面越大则软阴影的区域就越大（图中相似三角形的关系）</p><p>我们可以想象，若遮挡物Blocker的离接收物Receiver越近，相似三角形就会更小</p><p>这就很好的解释了为什么有“离物体越近的地方阴影就越硬”的这个现象</p><p><img src="/images/loading.jpg" data-original="/2022/03/11/2022-03-11-Games202-Lecture3-(Shadow-1)/image-20220312021607801.png" alt="image-20220312021607801"></p><p>恰巧笔者最近也在玩消光，有机会的话去游戏里好好观察一番</p><hr><p>打异度之刃2去咯  2022/3/12 2:20</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;在做opengl的时候做到了shadowmapping，效果做出来了但其实并不能算吃的很透&lt;/p&gt;
&lt;p&gt;刚巧想起之前在202已结搭建好了框架环境，可以成功把202娘跑起来&lt;/p&gt;
&lt;p&gt;所以会跟着202好好的把课听一遍&lt;/p&gt;
&lt;p&gt;这次开坑的任务：&lt;/p&gt;
&lt;p&gt;总结202课上精要内容，加入自己理解作为输出&lt;/p&gt;
&lt;p&gt;在作业1的框架上完成shadowmapping的硬阴影&lt;/p&gt;
&lt;p&gt;开始吧 Let ‘s go!&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>游戏引擎架构精要（才怪）③</title>
    <link href="https://aprilnavi.github.io/2022/03/08/2022-03-08-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E7%B2%BE%E8%A6%81%EF%BC%88%E6%89%8D%E6%80%AA%EF%BC%89%E2%91%A2/"/>
    <id>https://aprilnavi.github.io/2022/03/08/2022-03-08-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E7%B2%BE%E8%A6%81%EF%BC%88%E6%89%8D%E6%80%AA%EF%BC%89%E2%91%A2/</id>
    <published>2022-03-08T09:17:58.000Z</published>
    <updated>2022-03-09T10:05:00.150Z</updated>
    
    <content type="html"><![CDATA[<p>《Game Engine Architecture》是一直以来我很有兴趣也很想阅读的书，书的译者是我很敬重的milo叶劲峰前辈（魔方引擎中心的大大）。</p><p>但是由于自己基础不牢，再加上这本厚厚的大书所带来的畏难情绪，同时自己过于功利总是把时间抽去做容易提升的事情，</p><p>以及n个自己给自己找的理由，让这个阅读计划一直搁置。</p><p>但这学期拿到了暑期实习的offer，刚巧也在魔方，对于就业的压力就减小了很多</p><p>再加上自己有意往引擎方向发展，阅读这本书就提上了日程。</p><span id="more"></span><p>今天把第五章的东西看完，看的内容不多但是感觉有收获，</p><p>书上讲的东西很干货，特别是谈及链表那个地方确实给了人很大的启发</p><hr><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="5-3-容器"><a href="#5-3-容器" class="headerlink" title="5.3 容器"></a>5.3 容器</h2><p>这个章节讲了一些基本上常用的数据结构，比较详细的分析了他们适用的场景</p><p>并且为我们自己亲自编写他们也提供了很不错的方案，是我觉得很有用很精华的内容</p><hr><h3 id="5-3-2-迭代器"><a href="#5-3-2-迭代器" class="headerlink" title="5.3.2 迭代器"></a>5.3.2 迭代器</h3><p>问题c++的迭代器在我第一次学习的时候，我不知道他和直接i++的区别是什么</p><p>书中所说，迭代器像是数组索引或指针，可以移至下一个元素（我也知道）</p><p>但是！迭代器通常是容器类的<strong>友元</strong>，因此可以高效迭代访问容器，不向外面暴露容器类的实现细节</p><p>其次，迭代器简化了迭代过程，无论数据结构多复杂，我都可以<code> iterator++</code></p><p>这个又涉及到前置递增++i和后置递增i++的问题</p><p>原文：在深度流水线CPU上，前置递增必须完成递增才能使用这个值，会引起<strong>流水线停顿</strong></p><p>在for循环里面前置和后置没有区别，<strong>当用到值的时候建议使用后置递增</strong></p><p>在使用类类型的时候，由于前置和后置可能是自定义的运算符重载</p><p>而后置递增需要对对象进行拷贝，会造成性能消耗，因此<strong>在类类型尽量使用前置递增</strong></p><hr><h3 id="5-3-3-算法复杂度"><a href="#5-3-3-算法复杂度" class="headerlink" title="5.3.3 算法复杂度"></a>5.3.3 算法复杂度</h3><p>这个大家面试的时候应该都刷烂了，但是书里边对于复杂度的常见解释</p><p>写的不错所以还是可以记一下的：</p><p>若算法的运行时间和容器中的元素数目无关的话，称算法为O（1）；</p><p>若算法循环访问容器里面的元素，每个元素当访问一次，则算法为O（n）；</p><p>若算法有两层循环，每层循环访问每个元素一次，则算法为O（n2）（自动联想上标）；</p><p>若算法使用分治法（二分查找），每次都能消去余下元素的一半，则算法为O（logn）；</p><p>若算法执行一个子算法n次，且子算法为O（logn），则整个算法为O（nlogn）</p><p>最长预见的数量级O（1），O（logn）,O（n）,O（nlogn）,O（n2）</p><p>同时也应该考虑容器的内存布局和使用特性</p><p>数组的内存连续，更加缓存友好，且除了元素不需要额外的内存开销（对比链表需要存指向下一元素的指针）</p><p>若插入以及移除元素的速度很重要，则应该使用链表</p><hr><h3 id="5-3-4-自建容器"><a href="#5-3-4-自建容器" class="headerlink" title="5.3.4 自建容器"></a>5.3.4 自建容器</h3><p>这里对于是否使用自建的数据结构提供了讨论，使用自建容器有以下好处：</p><ul><li>可以自己控制如何分配内存，自由的进行优化</li><li>可自行提供第三方库没有的功能（stl中只能搜索单个最有关元素，而不能搜索n个）</li><li>不需要第三方库支持则可以消除第三方团队的外部依赖</li><li>可全权控制多线程或多核系统的保护机制</li></ul><hr><p>常见第三方：</p><p><strong>STL：</strong></p><p>优势：功能丰富，多平台的壮健表现，几乎所有c++编译器自带stl</p><p>缺点：难学，对于特定问题速度不如自建容器快，对比自建容器会占用更多内存</p><p>会进行许多动态分配，要控制stl的内存占用量</p><p>STL适合pc游戏引擎，因为对比游戏主机内存受限，缺乏高级CPU和虚拟内存</p><p>现代pc拥有高级虚拟内存系统，通常也能忽略物理内存不足的可能性</p><p><strong>Boost：</strong></p><p>优势：文档写得好，功能比stl更多，能有效处理智能指针</p><p>缺点：核心类是模板，可能会生成较大的lib，不适合小项目</p><p>不保证向后兼容，Boost团队也不提供保障。</p><hr><p>数组和动态数组不加赘述，没什么好说的</p><hr><p>链表这块讲的很不错：</p><p>外露式链表：</p><pre><code>template&lt;typename ELEMENT&gt;struct Link&#123;   Link&lt;ELEMENT&gt;* Prev;   Link&lt;ELEMENT&gt;* Next;   ELEMENT* Elem;&#125;</code></pre><p>节点数据结构和元素数据结构完全分离，每个节点含指针指向元素。</p><p>外露式链表的特点在于，一个元素可以置于多个链表中，只需要节点指向该元素</p><p>但分配节点时必须进行动态分配，许多时候会使用池分配器。</p><hr><p>侵入式链表：</p><pre><code>template&lt;typename ELEMENT&gt;struct Link&#123;   Link&lt;ELEMENT&gt;* Prev;   Link&lt;ELEMENT&gt;* Next;&#125;class SomeElement:public Link&lt;SomeElement&gt;&#123;   //其他成员&#125;</code></pre><p>使用侵入式链表的好处是，分配元素时无须再动态分配节点（已经获得了节点）</p><p>但每个元素不能置于多个列表中，（元素只有一个节点数据），因此侵入式链表不如外露式有弹性</p><hr><p>循环链表的结构一般会包含头尾指针：</p><pre><code>template&lt;typename ELEMENT&gt;struct Link&#123;   Link&lt;ELEMENT&gt;* Tail;   Link&lt;ELEMENT&gt;* Head;      //相关操作成员函数&#125;</code></pre><p>用Link类来管理头尾指针有些好处:</p><pre><code>template&lt;typename ELEMENT&gt;struct Link&#123;   Link&lt;ELEMENT&gt; Root; //包含了头尾指针         //相关操作成员函数&#125;</code></pre><p>这样一来最后节点的next和第一个节点的pre都是指向root的</p><p>这样设计能简化插入和移除的逻辑，我们先看看独立头尾指针移除元素的代码：</p><pre><code>void LinkList::remove(Link&lt;ELEMENT&gt;&amp; link)&#123;  if(link.next)link.next.pre=link.pre;  else this.Tail=link.pre  //移除链表末元素    if(link.pre)link.pre.pre=link.next;  else this.Head=link.next//移除链表首元素    link.pre=link.next=nullptr;&#125;</code></pre><p>在这个设计中首节点的pre和末节点的next必为空指针，若列表只有一个节点，则两个指针都会是空指针</p><p>不能单凭一个指针得知他是否属于一个链表</p><p>若使用root的设计：</p><pre><code>void LinkList::remove(Link&lt;ELEMENT&gt;&amp; link)&#123;  ASSERT(link.next);  ASSERT(link.pre);    link.next.pre=link.pre;  link.pre.pre=link.next;    link.pre=link.next=nullptr;&#125;</code></pre><p>最后节点的next和第一个节点的pre都是指向root的</p><p>因此若首节点的pre和末节点的next为空指针，则他不属于这个链表</p><hr><p>字典，散列表（哈希表）</p><p>笔者不可能去手写哈希函数所以感觉没什么好说的哈哈哈</p><p>感觉还是乖乖std::吧</p><hr><h2 id="5-4-字符串"><a href="#5-4-字符串" class="headerlink" title="5.4 字符串"></a>5.4 字符串</h2><p>问了问魔方的引擎前辈</p><p>那边好像基本上都是在改ue的，说在游戏引擎里面处理这个不多</p><p>而且ue内部的字符串管理也还行</p><p>那我就选择性忽略这章吧</p><hr><h2 id="5-5-引擎配置"><a href="#5-5-引擎配置" class="headerlink" title="5.5 引擎配置"></a>5.5 引擎配置</h2><p>5.5这章感觉也没有提供什么对我比较有启发的东西</p><p>讲到ini，xml还有注册表什么的感觉算是短期之内比较接触不到的东西</p><p>如果具体想做的话应该很快能找到不错的解决方案</p><hr><p>今天就到这吧 赶紧shadowmapping去了</p><p>2022.3.9 17:35</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;《Game Engine Architecture》是一直以来我很有兴趣也很想阅读的书，书的译者是我很敬重的milo叶劲峰前辈（魔方引擎中心的大大）。&lt;/p&gt;
&lt;p&gt;但是由于自己基础不牢，再加上这本厚厚的大书所带来的畏难情绪，同时自己过于功利总是把时间抽去做容易提升的事情，&lt;/p&gt;
&lt;p&gt;以及n个自己给自己找的理由，让这个阅读计划一直搁置。&lt;/p&gt;
&lt;p&gt;但这学期拿到了暑期实习的offer，刚巧也在魔方，对于就业的压力就减小了很多&lt;/p&gt;
&lt;p&gt;再加上自己有意往引擎方向发展，阅读这本书就提上了日程。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>第三周学习日志</title>
    <link href="https://aprilnavi.github.io/2022/03/07/2022-03-07-%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    <id>https://aprilnavi.github.io/2022/03/07/2022-03-07-%E7%AC%AC%E4%B8%89%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</id>
    <published>2022-03-07T10:31:58.000Z</published>
    <updated>2022-03-11T18:25:28.859Z</updated>
    
    <content type="html"><![CDATA[<p>第三周的学习日志哒</p><span id="more"></span><h1 id="Monday"><a href="#Monday" class="headerlink" title="Monday"></a>Monday</h1><p>上午的状态很不错，整个人都神采奕奕的</p><p>把光照改进成了bling phong，加了gamma校正和点光源的衰减</p><p>做起来的效果不错，而且一整个上午的效率也很高，明天可以开始做Shadow mapping</p><p>上午上课发生了一点小插曲，我在上PS课的时候用着自己电脑在写shader</p><p>老师过来问我在干什么我说在写着色器，老师说我是毕业想去做游戏吗</p><p>我说已经进tx了（实则转正没一撇），然后老师就以整层楼都听得见的声音直接大喊了一声</p><p>（说起来这个offer真的给了我很多，信心，实力，虚荣，人脉，好的坏的都有）</p><p>然后老师坏笑的说：如果我挂掉你会怎么样呢，我：球球放过</p><p>然后老师就推了一个后辈的v给我，叫我好好带带，带不动就挂我（晕）</p><p>然后稍微看了下大二上在跟着unity教程做demo，看着是还不错，但是不知道基础怎么样</p><p>稍微了解了下挺多行情也术语也不了解（还好不算太离谱的卷王）</p><p>其实挺好的，游戏有在做，后端也有在搞，不需要版号掐死就死路一条</p><hr><p>下午补考完以后基本上是做大牢</p><p>补考本身是并不能算顺利但也并不是完全寄，只能说期望能过吧</p><p>四点就来图书馆想着写一两个小时博客，结果摸鱼边码字字码了不少但是还没写完</p><p>最后因为版号的事情人也焦虑的不行，只能说游戏行业真的太难了</p><p>之后的日子会很难熬吧，但我早已经斩断后路了，毕竟重现前辈所期望的世界是我的U咩呢</p><hr><p>希望七点二十之前可以把UE打开吧，博客写到这样就算了</p><hr><h1 id="Tuesday"><a href="#Tuesday" class="headerlink" title="Tuesday"></a>Tuesday</h1><p>昨天晚上因为一些琐事没有睡好，大概是三点多才睡着</p><p>早上一下睡到了五十分才醒，一醒来就往教室跑，除开很困之外人的精神面貌还不错（好像也不好）</p><p>但起码好在我是个精神独立的人，不会因为失去什么就停止前进</p><p>身体感觉到了明显的劳累感，不过我知道这是因为我把作息调成了不熬夜的作息导致的（好事）</p><p>早上做shadowmapping只做了一半，感觉好难，最后还是跟着源码粘上去才出了效果</p><p>希望明天花多点时间能够把shadowmapping搞明白。</p><hr><p>中午下课把电脑开开心心放图书馆</p><p>然后下午下课过来发现电脑给人挪走了，一天的好心情直接急急急</p><p>希望晚上抽雷神的时候运气可以好点吧</p><hr><p>九条五命，西风长枪两把，和璞鸢一把，毕业心海一只</p><p>水群时间一大把，博客都没有肝完呜呜呜呜</p><p>晚上看了一小时光追课全程发呆，什么都听不懂属实小emo</p><p>好在心情还是不错的，但不得不说萌萌真的很厉害我真的很敬佩她</p><p>我还零基础的时候她就在拿MiniGame打比赛，gameplay做的很好</p><p>我们现在联系的少了，我记得拿到了魔方的oc告诉她的时候她反应不大</p><p>（看来是不稀罕了呜呜呜）她确实没有让我失望，</p><p>晚上直接列式问光追里面的积分和采样算的结果如何（tql）而且她真的是很谦虚的人</p><p>如果我的成长速度是5那她估计是15，但我也会好好加油的</p><hr><h1 id="Wednesday"><a href="#Wednesday" class="headerlink" title="Wednesday"></a>Wednesday</h1><hr><p>早上睡到了八九点，一早上都没怎么肝，就想着东奔西跑给图书馆占位置了</p><p>os课下半节直接逃了，回宿舍打原神去了笑死</p><p>一中午没睡下午精神也不是很好</p><hr><p>说是学习日志到现在根本也还没进状态吧</p><p>不过倒是和鸡哥聊了很多转正的事情，对转正更有信心了</p><p>在居居的群了钓了一下午鱼心情蛮好的还</p><p>虽然最后也是什么都没做哈哈哈哈</p><hr><p>今天的任务定个小目标吧</p><ol><li><p>补完昨天的博客</p></li><li><p>搞完昨天没搞完的shadowmapping（这也算是早上没搞完的）</p></li><li><p>gameplay做完一个模块吧</p></li></ol><p>今日事今日毕冲冲冲！ </p><hr><h1 id="Thursday"><a href="#Thursday" class="headerlink" title="Thursday"></a>Thursday</h1><p>搞了一整个晚上的shadow map</p><p>rtr到了但是翻了几页就劝退了</p><h1 id="Friday"><a href="#Friday" class="headerlink" title="Friday"></a>Friday</h1><p>单单是重新把框架搞好</p><p>调试shadowmap什么的就做了一早上</p><p>回来一边摸鱼一边学习把202第一章关于shadow的整理归纳好了</p><p>写完博客已经是2点钟了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;第三周的学习日志哒&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>年糕老师的ue4小课堂（第二期）</title>
    <link href="https://aprilnavi.github.io/2022/03/07/%E5%B9%B4%E7%B3%95%E8%80%81%E5%B8%88%E7%9A%84ue4%E5%B0%8F%E8%AF%BE%E5%A0%82%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%9C%9F%EF%BC%89/"/>
    <id>https://aprilnavi.github.io/2022/03/07/%E5%B9%B4%E7%B3%95%E8%80%81%E5%B8%88%E7%9A%84ue4%E5%B0%8F%E8%AF%BE%E5%A0%82%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%9C%9F%EF%BC%89/</id>
    <published>2022-03-07T10:31:58.000Z</published>
    <updated>2022-03-07T10:59:08.634Z</updated>
    
    <content type="html"><![CDATA[<p>在ue方面笔者完全是个萌新，糕糕前辈在我进入某大佬群时主动加了我的好友（现在想来感动的能哭出声）</p><p>在我学习ue时不吝赐教，为我提供了许多资料，语气也十分的和蔼温柔</p><p>每次遇到什么问题发消息几乎都是秒回，解答了我的许多疑惑（我哭死）</p><p>这篇博客会做成一个对话的专栏形式，会记录一些前期学习遇到的疑问</p><p>不会有固定的大纲，记录的风格是诙谐轻松的（顺利的话会一直写下去？）</p><p>最重要的是这些遇到并得到解答的问题我不希望今天获取然后明天就失忆了</p><p>这些知识对初学者应该是很有帮助的（确信），所以我很乐意记录这样一个快乐的过程</p><span id="more"></span><hr><p>这次笔者会记录在学校学习的第二周和糕糕前辈发生的有趣的对话</p><hr><h2 id="第一幕-3-1"><a href="#第一幕-3-1" class="headerlink" title="第一幕 3.1"></a>第一幕 3.1</h2><p>四月：糕糕你之前发我的那个有关assert的文章还在吗，哦对了说起来断言算是c++的机制还是算是ue的机制呢</p><p>糕糕：是ue的机制，你也可以自己写，不过就不叫断言了。你知道断言为什么叫断言吗。</p><p>四月：会引发一个中断！（确信）</p><p>糕糕：没错，断言的意思差不多就类似中断的文字版。</p><hr><h2 id="第二幕-3-2"><a href="#第二幕-3-2" class="headerlink" title="第二幕 3.2"></a>第二幕 3.2</h2><p>四月：糕糕，元数据metadata是什么</p><p>糕糕：元数据是用来描述数据的数据，<a href="https://www.ruanyifeng.com/blog/2007/03/metadata.html">https://www.ruanyifeng.com/blog/2007/03/metadata.html</a></p><p>四月：这样，那ue的元数据是什么，文件大小时间那些的吗</p><p>糕糕：UE的UProperty有Meta标签，不过可以自己加，只能editor识别。或者说这个所谓的描述其实没有固定添加的地方</p><p>只是看你的程序对他处不处理。</p><p>四月：噢噢正是这样所以UE editor能把这些当成资产来使用，这就是元数据</p><hr><h2 id="第三幕-3-2"><a href="#第三幕-3-2" class="headerlink" title="第三幕 3.2"></a>第三幕 3.2</h2><p><strong>四月：</strong>自带的FPS模板写了一堆前向声明诶</p><p><img src="/images/loading.jpg" data-original="/2022/03/07/%E5%B9%B4%E7%B3%95%E8%80%81%E5%B8%88%E7%9A%84ue4%E5%B0%8F%E8%AF%BE%E5%A0%82%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%9C%9F%EF%BC%89/_4VZ%25%5D%25DHR%5B7%60RTAIZ79GOR.png" alt="img"></p><p><strong>糕糕：</strong>C++ 必须写这个，必须能不用#include就不用</p><p><strong>四月：</strong>噢噢原来是这样，我之前都是都是#include</p><p><strong>糕糕：</strong>#include的话 其中某个头文件改了，链式增加编译数量，而且会有重叠引用的问题</p><p><strong>四月：</strong>之前demo就遇到过，就武器类引用了我的角色，角色类也引用我的武器，然后乱糟糟的，可能哪边不小心改错了就过不去编译。</p><p><strong>糕糕：</strong>还有这个前置声明，我推荐在头文件里写在要用的地方，而不是写在最上面，方便复制片段代码</p><p>还有个事，struct不能前置声明</p><p><strong>四月：</strong>所以class和struct的区别又多了一个，那我怎么天天看到它们只有一个public一个private的区别</p><p>糕糕：其实是UE里不能这样</p><p><strong>四月：</strong>可恶啊</p><p><strong>糕糕：</strong>因为UE的struct只能放到栈里构造，而class只能在堆里构造，UE的uclass 创建变量的时候只能用 指针，ustruct只识别非指针</p><p>所以ustruct，在头文件里构造这个类的时候就要明确要多少内存，所以就得在这里include进来了。</p><p>而class在构造这个类的时候是用的指针，固定大小的，所以可以前置声明。</p><p><strong>四月：</strong>呜呜呜糕糕真是好老师</p><p><strong>糕糕：</strong>所以可恶的C++，现在我学ts就完全好多了</p><hr><h2 id="第四幕-3-2"><a href="#第四幕-3-2" class="headerlink" title="第四幕 3.2"></a>第四幕 3.2</h2><p>四月：UgameplayStatic::里面有什么常用的api吗</p><p>糕糕：看源码，基本上都是常用Api吧。但实际项目中，最好自己写个类似的库</p><p>四月：我自己实现一遍吗</p><p>糕糕：嗯嗯，因为他get出来的是UE原来的类型，要cast一下</p><p><img src="/images/loading.jpg" data-original="/2022/03/07/%E5%B9%B4%E7%B3%95%E8%80%81%E5%B8%88%E7%9A%84ue4%E5%B0%8F%E8%AF%BE%E5%A0%82%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%9C%9F%EF%BC%89/T39@HAUYOY4%7BNE%7D(QPL)RKU.png" alt="img"></p><p>比如最常用的这个，正经项目你肯定会自己写个Gamemode吧，你每次都要cast一下</p><p>直接对自己的gamemode写个static get自己的实例算了 反正是单例。</p><p>四月：避免cast是为什么呢，性能开销太大了吗</p><p>糕糕：嗯，损耗很大。</p><p><img src="/images/loading.jpg" data-original="/2022/03/07/%E5%B9%B4%E7%B3%95%E8%80%81%E5%B8%88%E7%9A%84ue4%E5%B0%8F%E8%AF%BE%E5%A0%82%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%9C%9F%EF%BC%89/%E5%8D%95%E4%BE%8B.png" alt="img"></p><p>写个单例大概像这样的</p><p>四月：单例不是考虑到线程安全会有什么懒汉式还有其他的吗</p><p>糕糕：Gamemode的生命周期不用自己管理，所以我们只用存他的指针返回他的指针就是了</p><p>四月：所以引擎会帮我们解决对吗</p><p>糕糕：嗯嗯对的，这样只有第一次有cast损耗，后面放tick里也没啥问题了</p><hr><h2 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h2><p>四月：我想玩那个车车游戏</p><p>糕糕：base.apk</p><p>四月：这车真的很难开，为什么你漂移还能炸对手</p><p>糕糕：游戏开发者一般是技术最好的吧，其实一般来说是策划，但这移动算法都是我写的</p><p>四月：里面的按钮居然都点不了！只有广告是可以点的，老板估计很开心</p><p>糕糕：说起来 你想去大厂的话，一定要想办法转正或者毕业就直接去大厂，不然工作几年之后很难的</p><p>我这边的tx基本上只招资深的<img src="/images/loading.jpg" data-original="/2022/03/07/%E5%B9%B4%E7%B3%95%E8%80%81%E5%B8%88%E7%9A%84ue4%E5%B0%8F%E8%AF%BE%E5%A0%82%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%9C%9F%EF%BC%89/2FFS%7B6G@M3$ZUWUK%25SWE0H.gif" alt="img">普通的和高级的基本上都是从实习生就在Tx的</p><p>四月：我当然知道啦，所以转正我特别重视，毕竟现在版号不发了，是游戏圈的紧要关头，可能没转正成功我就回家了。</p><p>我打算死磕tx了，毕业拿转正offer之前都不算高枕无忧。</p><hr><p>笔者写这些的时候，又听到了一些所谓“小道消息”，说春招的hc被卡了很多，即使自己不需要春招已经上岸</p><p>但还是感觉到了不小的压力，也为整个中国游戏行业的未来狠狠的捏了一把汗。</p><p>再说下去要emo了，这样可不行，人还是得开开心心的，毕竟我又是月亮又是太阳！</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;在ue方面笔者完全是个萌新，糕糕前辈在我进入某大佬群时主动加了我的好友（现在想来感动的能哭出声）&lt;/p&gt;
&lt;p&gt;在我学习ue时不吝赐教，为我提供了许多资料，语气也十分的和蔼温柔&lt;/p&gt;
&lt;p&gt;每次遇到什么问题发消息几乎都是秒回，解答了我的许多疑惑（我哭死）&lt;/p&gt;
&lt;p&gt;这篇博客会做成一个对话的专栏形式，会记录一些前期学习遇到的疑问&lt;/p&gt;
&lt;p&gt;不会有固定的大纲，记录的风格是诙谐轻松的（顺利的话会一直写下去？）&lt;/p&gt;
&lt;p&gt;最重要的是这些遇到并得到解答的问题我不希望今天获取然后明天就失忆了&lt;/p&gt;
&lt;p&gt;这些知识对初学者应该是很有帮助的（确信），所以我很乐意记录这样一个快乐的过程&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>年糕老师的ue4小课堂（第一期）</title>
    <link href="https://aprilnavi.github.io/2022/03/07/2022-03-04-%E5%B9%B4%E7%B3%95%E8%80%81%E5%B8%88%E7%9A%84ue4%E5%B0%8F%E8%AF%BE%E5%A0%82%EF%BC%88%E7%AC%AC%E4%B8%80%E6%9C%9F%EF%BC%89/"/>
    <id>https://aprilnavi.github.io/2022/03/07/2022-03-04-%E5%B9%B4%E7%B3%95%E8%80%81%E5%B8%88%E7%9A%84ue4%E5%B0%8F%E8%AF%BE%E5%A0%82%EF%BC%88%E7%AC%AC%E4%B8%80%E6%9C%9F%EF%BC%89/</id>
    <published>2022-03-07T09:31:58.000Z</published>
    <updated>2022-03-07T09:02:02.104Z</updated>
    
    <content type="html"><![CDATA[<p>在ue方面笔者完全是个萌新，糕糕前辈在我进入某大佬群时主动加了我的好友（现在想来感动的能哭出声）</p><p>在我学习ue时不吝赐教，为我提供了许多资料，语气也十分的和蔼温柔</p><p>每次遇到什么问题发消息几乎都是秒回，解答了我的许多疑惑（我哭死）</p><p>这篇博客会做成一个对话的专栏形式，会记录一些前期学习遇到的疑问</p><p>不会有固定的大纲，记录的风格是诙谐轻松的（顺利的话会一直写下去？）</p><p>最重要的是这些遇到并得到解答的问题我不希望今天获取然后明天就失忆了</p><p>这些知识对初学者应该是很有帮助的（确信），所以我很乐意记录这样一个快乐的过程</p><span id="more"></span><hr><p>让我们有请今天的嘉宾，糕糕老师！</p><p><strong>糕糕：</strong>大家好，我是一个工作不到两年的菜鸡（看来糕糕老师确实很谦虚呢）</p><hr><h2 id="第一幕-2-23"><a href="#第一幕-2-23" class="headerlink" title="第一幕 2.23"></a>第一幕 2.23</h2><p>某天晚上我新建了个了第三人称模板，想找个项目做做重温一下act的感觉，在搞动画蓝图的时候有了以下一幕：</p><p><strong>四月：</strong>那个人向哪里走就向哪里转向的，是在哪里设置的？</p><p><strong>糕糕 ：</strong>MovementComponent 还是 Character的默认属性那里忘记了</p><p><strong>四月：</strong>我还是开中文吧，感觉用英文很多东西反应不过来</p><p><strong>糕糕：</strong>建议是开中文语言，节点的名字和变量的名字英文</p><p><img src="/images/loading.jpg" data-original="/2022/03/07/2022-03-04-%E5%B9%B4%E7%B3%95%E8%80%81%E5%B8%88%E7%9A%84ue4%E5%B0%8F%E8%AF%BE%E5%A0%82%EF%BC%88%E7%AC%AC%E4%B8%80%E6%9C%9F%EF%BC%89/(S9NBOMCU)3C7$7ZNKGC%7D5O-16463936762971.png" alt="img"></p><p><img src="/images/loading.jpg" data-original="/2022/03/07/2022-03-04-%E5%B9%B4%E7%B3%95%E8%80%81%E5%B8%88%E7%9A%84ue4%E5%B0%8F%E8%AF%BE%E5%A0%82%EF%BC%88%E7%AC%AC%E4%B8%80%E6%9C%9F%EF%BC%89/QQ%E5%9B%BE%E7%89%8720220304193559.png" alt="img"></p><p><strong>糕糕：</strong>嗯对是这样</p><p><strong>四月：</strong>奇怪了，我在blendspace里面看都是正常的，有很多个方向的移动，连上去之后，怎么跑怎么动都是一个样子</p><p><img src="/images/loading.jpg" data-original="/2022/03/07/2022-03-04-%E5%B9%B4%E7%B3%95%E8%80%81%E5%B8%88%E7%9A%84ue4%E5%B0%8F%E8%AF%BE%E5%A0%82%EF%BC%88%E7%AC%AC%E4%B8%80%E6%9C%9F%EF%BC%89/image-20220304194659446.png" alt="image-20220304194659446"></p><p><strong>糕糕：</strong>白色那里选场景里的Character，这可是蓝图调试基础</p><p><strong>四月：</strong>呜呜呜基础</p><p><strong>糕糕：</strong>没事，我也是自学才看到这个功能的</p><p><strong>四月：</strong>算了我把速度打印到屏幕吧，这样方便一点</p><p><strong>四月：</strong>我草，破案了，他的速度只有正值，我是傻逼啊</p><p><strong>糕糕：</strong>哈哈哈哈哈哈哈，这个就是做项目的好处了，能学到解决问题的思路，所以即使之后做的不是这个类型的游戏之类的也能做</p><p><strong>四月：</strong>他这个自带模板有大病啊，怪不得要设置成自动旋转，速度怎么可能会没有负值啊，然后blendspace只做了前进的</p><p><strong>糕糕：</strong>速度一般都是0～动画的实际速度，看设计的。</p><hr><p>次日：</p><p><strong>四月：</strong>完了，我是怎么说出昨天晚上那些话的，正常来说速度怎么可能有负值呢</p><p><strong>糕糕：</strong>所以我没多想</p><p>![image-20220304200942589]image-20220304200942589.png)</p><p><strong>四月：</strong>这样，感觉好缺编程经验，断言，调试，句柄，宏这些我都没学过，怎么恶补</p><p><strong>糕糕：</strong>你是想刚毕业就有10年经验吗</p><p><strong>四月：</strong>啊可是这个难道不是毕业生标配吗，我怎么感觉别人都会（事实上这个傻逼在过度焦虑）</p><p><strong>四月：</strong>哈哈哈哈哈哈哈哈哈，你这一说我就放心了</p><p><strong>糕糕：</strong>嗯 我的意思就是，这些其实都是在做项目过程中学的，所以没有恶补的方法</p><p><strong>四月 ：</strong>噢噢这样，之前精力基本上都在看理论，怪不得都不知道这些，实操少了</p><hr><p>由此可见，gameplay的实操本身就是最好的学习资料</p><hr><h2 id="第二幕-2-25"><a href="#第二幕-2-25" class="headerlink" title="第二幕 2.25"></a>第二幕 2.25</h2><p>这篇特别长但我觉得特别有营养，是经典</p><p>有天下午在图书馆看大象无形（确实是真的看不懂），看到一半回忆起当时面试被问到的问题</p><p><strong>四月：</strong>gamemode和gamestate的区别是什么，关卡蓝图又是什么</p><p><strong>糕糕：</strong>终于到这里了</p><p><strong>四月：</strong>没有，还没到这里，是我在读书的时候想起了面试官问我的问题。</p><p><strong>糕糕：</strong>这些东西都是属于Gameplay框架里的一部分，Gameplay框架的定义，它是一个“房间制多人联机回合计分对战游戏框架”，所以你做单机游戏的时候，实际上是用不到的。</p><p><strong>四月：</strong>所以做单机游戏的时候 ，是不是我把规则写gamemode和gamestate都可以</p><p><strong>糕糕：</strong>是这样，但是你一旦做多人游戏，这俩的网络同步状态，以目前游戏用得比较多的UE联机方式，DS服务器架构下，<br>一个游戏房间里拥有一个中央服务端只处理服务器逻辑不处理渲染，而所有玩家都是客户端。在这种架构下，服务端跑了一个UWorld，客户端也跑了一个UWorld，但是只有服务端的UWorld是真实的，其他所有的都是复制品。</p><p><strong>四月：</strong>所以说客户端是对服务端的拙劣模仿，有看到这样的形容</p><p><strong>糕糕：</strong>对的，然后 Gamemode Gamestate都是继承actor的，Gamemode仅在服务端上生成，不复制到客户端，Gamestate在所有端均生成，以服务端为准，其他为复制品</p><p><strong>四月：</strong>噢噢原来是这样，那关卡蓝图呢</p><p><strong>糕糕：</strong>关卡蓝图纯本地，一般不使用关卡蓝图，关卡蓝图不是Actor哦</p><p><strong>四月：</strong>原来是这样</p><p><strong>糕糕：</strong>Gamemode是UE的Gameplay框架的一部分，所以 Gamemode 的设置里的这些东西也是</p><p><strong>糕糕：</strong>先不看Pawn，先看PlayerController，只在拥有的客户端上生成，服务端拥有所有客户端的 PlayerController，所以，玩家在自己的PlayerController，修改了值啊，执行了什么事件啊之类的，只有服务器知道，其他客户端是不知道的，所以又来了个PlayerState</p><p><strong>四月：</strong>啊这</p><p><strong>糕糕：</strong><a href="https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/Framework/">https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/Framework/</a></p><p>你的问题文档都有，只是“计分多人游戏框架”这件事是我自己总结的，网上没有的，你先理解了这个定义，用这个定义去理解他的框架应该会更容易些，不然容易误解某些功能233。</p><p><strong>四月：</strong>虚幻引擎真的好难学啊</p><p><strong>糕糕：</strong>成也Gameplay框架败也Gameplay框架，成在，你作为没有经验的，不是架构师，理解它用它，就能出游戏了；</p><p>成在，你作为没有经验的，不是架构师，理解它用它，就能出游戏了。</p><p><strong>四月：</strong>我该怎么做呜呜呜呜</p><p><strong>糕糕：</strong>开整！现在就用它整个多人联机fps</p><p><strong>糕糕：</strong>Gamemode用来写当前游戏模式的服务器要执行的事件，比如LOL，假如在10分钟出大龙，这件事就是写Gamemode里的。</p><p>而游戏已经进行了10分钟，大龙已经被击杀了多少次，是在Gamestate里面。</p><p><strong>四月：</strong>gamemode是写事件，state是记录信息条件，这样吗</p><p><strong>糕糕：</strong>这样，大龙例子不是很好，那就红buff吧。红BUFF有个特点，你没视野的时候被打死，你不知道红BUFF没了。没错，他的生成和存在状态就是存Gamemode里的。</p><p><strong>四月：</strong>所有野怪都这样</p><p><strong>糕糕：</strong>因为Gamemode不在客户端同步，你可以设置只在客户端有视野的时候，Gamemode才把对应状态通过RPC发过去</p><p><strong>四月：</strong>那gamestate还是记信息嘛，每个客户端一份，然后服务端的是真的，其他都是复制品</p><p><strong>糕糕：</strong>嗯，gamestate记全场客户端人尽皆知的事，游戏持续时间……大逃杀的话，剩余人数。但如果是LOL的话，</p><p>玩家杀人数可以记到gamestate，但是补刀数 装备在 playerstate，可以理解吗</p><p><strong>四月：</strong>不太理解诶，补刀数不是和杀人数战绩按理说不是一样的吗</p><p><strong>糕糕：</strong>不一样的哦，你观察下打野英雄，不露脸不显示补刀数的，防止你知道打野英雄的发育情况了</p><p><strong>四月：</strong>噢噢，所以补刀并不是全场客户端人尽皆知的事情，所以就并不是记录在Gametate而是在Playerstate里面。这样我就明白了</p><hr><p>这个专栏感觉还是很生动的，打算以一星期一次的频率更新一次（前提是有提问）</p><p>这一期太长了剩下就放到下一期来吧！2022.3.7</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;在ue方面笔者完全是个萌新，糕糕前辈在我进入某大佬群时主动加了我的好友（现在想来感动的能哭出声）&lt;/p&gt;
&lt;p&gt;在我学习ue时不吝赐教，为我提供了许多资料，语气也十分的和蔼温柔&lt;/p&gt;
&lt;p&gt;每次遇到什么问题发消息几乎都是秒回，解答了我的许多疑惑（我哭死）&lt;/p&gt;
&lt;p&gt;这篇博客会做成一个对话的专栏形式，会记录一些前期学习遇到的疑问&lt;/p&gt;
&lt;p&gt;不会有固定的大纲，记录的风格是诙谐轻松的（顺利的话会一直写下去？）&lt;/p&gt;
&lt;p&gt;最重要的是这些遇到并得到解答的问题我不希望今天获取然后明天就失忆了&lt;/p&gt;
&lt;p&gt;这些知识对初学者应该是很有帮助的（确信），所以我很乐意记录这样一个快乐的过程&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>主流抗锯齿方案对比</title>
    <link href="https://aprilnavi.github.io/2022/03/04/%E4%B8%BB%E6%B5%81%E6%8A%97%E9%94%AF%E9%BD%BF%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94/"/>
    <id>https://aprilnavi.github.io/2022/03/04/%E4%B8%BB%E6%B5%81%E6%8A%97%E9%94%AF%E9%BD%BF%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94/</id>
    <published>2022-03-04T11:00:58.000Z</published>
    <updated>2022-03-04T11:01:59.010Z</updated>
    
    <content type="html"><![CDATA[<p>感觉这个坑对于经常玩游戏的玩家应该还算有一点吸引力</p><p>因为笔者最近在研究opengl的时候做到了离屏msaa的部分</p><p>觉得如果能自己好好学习一下抗锯齿的几种类型并简要的介绍一下</p><p>想必对自己学习历程一定会有很大的帮助</p><span id="more"></span><p>我们不会在这里阐述锯齿产生的原因，详见games101 P6的那节，同时我们假设读者都了解熟悉光栅化的过程</p><p>我们也不会拿源码出来讲解抗锯齿的实际使用</p><p>（PS：确实除了msaa其他都没做过，可能会把opengl做离屏msaa那一章拿出来讲解一下）</p><p>本篇内容当然还是以网上的内容摘要总结为主（其实就是写给自己复习用的）</p><p>我们会尽量从原理和优缺点分析这些抗锯齿方案。</p><h1 id="MSAA，SSAA"><a href="#MSAA，SSAA" class="headerlink" title="MSAA，SSAA"></a>MSAA，SSAA</h1><p><strong>MSAA（MultiSampling Anti-Aliasing）（多重采样反走样）</strong></p><p><strong>SSAA（Super-Sampling Anti-Aliasing）（超级采样反走样）</strong></p><p>从名字我们就能很容易看出两种抗锯齿采取的办法是在增加了采样的次数</p><p>msaa和ssaa我认为是相似的，虽然他们只在对子像素点处理方式上有着细微区别</p><p>但所耗费的开销差别的巨大的，这也因此让ssaa直接就退出了历史舞台，因此我们会细嗦MSAA</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>他们的具体做法都是在一个像素内增加子像素点，ssaa会对每个子像素点都进行一次单独的着色计算</p><p>在最后将子像素点的颜色合并到对应的像素点。SSAA是最直接也是效果最好的抗锯齿方法。</p><p>像素本身就是计算机图像的最小不可分最小的单位，所以会将整个纹理拉大到更高倍数的缓存上进行采样</p><p>以常见的SSAAx4为例，在面对一张需要以1920x1080（1080P）像素渲染的画面时</p><p>SSAA会首先渲染一张尺寸为3840x2160（4K）像素的缓存，再在这种长宽都乘以2的画面上进行采样</p><p>采样的精度和效果当然是最理想的，但是也可以想象，这种对于硬件资源的消耗非常大，成本也非常高。</p><hr><p>MSAA出于性能考虑，同一个像素上的多个子像素点，不会每个都进行一次像素着色计算</p><p>而是共享像素中心点的像素计算结果。</p><p>对于每个像素点，如果上面对应的子像素点至少有一个通过了覆盖测试，就会进行<strong>一次</strong>采样</p><p>计算的插值采样位置是像素的中心位置。一次采样的结果，会用于多个次像素采样点中。</p><p>计算完成后，每个通过覆盖测试的次像素点还需要进行 <strong>depth-stencil test/深度-模板测试</strong></p><p>这个测试和普通的单个像素的深度-模板测试是一样的，只是现在发生在次像素点而已。</p><p>当深度-模板测试通过后，在像素中心位置采样的结果值就会写入到对应的次像素点。</p><hr><p>使用MSAA是比较简单的，重要工作都是 GPU 来自动完成的，我们只需要使用即可。</p><p>在 OpengGL 中，使用 MSAA 只需要将 FrameBuffer 的格式设置成相应的 NxMSAA 格式</p><p>将 FrameBuffer 作为渲染输出，就是 MSAA的效果。</p><p>将 MSAA 格式贴图 Blit 到普通的格式，OpenGL 会自动完成 resolve 的工作。</p><p>我们使用 MSAA 时也要注意，要尽量避免过多地进行 resolve 操作</p><p>比如经常将 MSAA 格式贴图作为贴图输入，又作为 RenderTarget 来输出。这样会不断进行 resovle 操作，造成额外的性能消耗。</p><p>（草这说的好像就是我）</p><p>如果是使用现代的图形 API，则一般需要显式地调用 resolve，整个过程也更加可控。</p><p>（懂了opengl不算现代图形api）</p><hr><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：使用简单方便，效果好。</p><p>缺点：因为是在光栅化阶段做的抗锯齿，抗锯齿这部分是由硬件完成的，会额外消耗大量内存和带宽</p><p>对于延迟渲染来说，GBuffer 本身就已经很大了，如果再使用 MSAA，额外的带宽消耗极大。</p><p>因此延迟渲染一般不会使用 MSAA来作为实现抗锯齿手段。</p><p>而目前大部分 PC 端游戏都是基于延迟渲染管线的，包括Unity 的 HDRP ，所以 PC 游戏一般不会使用 MSAA。</p><p>（因为自己没做过延迟渲染，所以关于延迟渲染的部分是抄的网上的233333）</p><hr><h1 id="FXAA"><a href="#FXAA" class="headerlink" title="FXAA"></a>FXAA</h1><p><strong>FXAA（Fast Approximate Anti-Aliasing）（快速近似抗锯齿）</strong></p><p>它是传统MSAA（多重采样抗锯齿）效果的一种高性能近似值。运行于目标游戏渲染管线的后期处理阶段</p><p>它只是单纯的后期处理着色器，不依赖于任何GPU计算API。</p><p>正因为如此，FXAA技术对显卡没有特殊要求，完全兼容NVIDIA、AMD的不同显卡(MLAA仅支持A卡)和DX9、DX10、DX11。</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>除了增加每个像素点的采样数，我们实现抗锯齿的另一种方式就是后处理。</p><p>考虑到大部分情况下，我们想要抗锯齿的部分，其实都只是在物体边缘或者高光变化的部分</p><p>我们通过后处理的方式，找出图像块之间的边缘，然后根据边缘信息对边缘两侧的图像进行混合处理，达到抗锯齿的效果。</p><p>这类基于后处理的抗锯齿方式也叫做<strong>形变抗锯齿/Morphological antialiasing</strong></p><p>但是任何事物都是辩证的，正如同其名，FXAA毕竟是一种“比较廉价”的抗锯齿技术</p><p>在大多数的游戏应用中，效果终究不及传统的MSAA，适用于性能不高的电脑配置。</p><p>具体的FXAA算法可以看这篇优质博客：</p><p><a href="https://zhuanlan.zhihu.com/p/431384101">主流抗锯齿方案详解（三）FXAA - 知乎 (zhihu.com)</a></p><p>（其实很多观点也是扒的人家和百度百科的，这位作者的文真的给了我很大的启发，有机会的话建议都好好读一遍）</p><h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：FXAA 的优点就是集成比较方便，只需要一个 Pass 来实现抗锯齿，</p><p>同时提供了quality和console两个版本，是目前手机上的最常用的抗锯齿方式。</p><p>缺点：FXAA在带来超快速运算的同时，也带来了精度和质量上的损失。</p><p>而且由于FXAA是基于后处理判断边界来实现的，因此没有次像素特性，在光照高频(颜色变化很快)的地方会不稳定。</p><p>单独看静态的场景没有问题，但是移动摄影机时，就会导致一些闪烁。</p><hr><h1 id="TAA"><a href="#TAA" class="headerlink" title="TAA"></a>TAA</h1><hr><h1 id="SMAA"><a href="#SMAA" class="headerlink" title="SMAA"></a>SMAA</h1><hr><h1 id="DLSS"><a href="#DLSS" class="headerlink" title="DLSS"></a>DLSS</h1><hr><p>很多很多内容都来自，谢谢这位作者，仅做自己学习记录之用，若有雷同，无意冒犯</p><p><a href="https://www.zhihu.com/column/c_1210266723531976704">实时渲染学习笔记 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;感觉这个坑对于经常玩游戏的玩家应该还算有一点吸引力&lt;/p&gt;
&lt;p&gt;因为笔者最近在研究opengl的时候做到了离屏msaa的部分&lt;/p&gt;
&lt;p&gt;觉得如果能自己好好学习一下抗锯齿的几种类型并简要的介绍一下&lt;/p&gt;
&lt;p&gt;想必对自己学习历程一定会有很大的帮助&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>游戏引擎架构精要（才怪）②</title>
    <link href="https://aprilnavi.github.io/2022/03/03/2022-03-03-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E7%B2%BE%E8%A6%81%EF%BC%88%E6%89%8D%E6%80%AA%EF%BC%89%E2%91%A1/"/>
    <id>https://aprilnavi.github.io/2022/03/03/2022-03-03-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E7%B2%BE%E8%A6%81%EF%BC%88%E6%89%8D%E6%80%AA%EF%BC%89%E2%91%A1/</id>
    <published>2022-03-03T13:36:58.000Z</published>
    <updated>2022-03-03T14:25:58.451Z</updated>
    
    <content type="html"><![CDATA[<p>《Game Engine Architecture》是一直以来我很有兴趣也很想阅读的书，书的译者是我很敬重的milo叶劲峰前辈（魔方引擎中心的大大）。</p><p>但是由于自己基础不牢，再加上这本厚厚的大书所带来的畏难情绪，同时自己过于功利总是把时间抽去做容易提升的事情，</p><p>以及n个自己给自己找的理由，让这个阅读计划一直搁置。</p><p>但这学期拿到了暑期实习的offer，刚巧也在魔方，对于就业的压力就减小了很多</p><p>再加上自己有意往引擎方向发展，阅读这本书就提上了日程。</p><span id="more"></span><hr><h1 id="第四章-三维数学"><a href="#第四章-三维数学" class="headerlink" title="第四章  三维数学"></a>第四章  三维数学</h1><p>第四章基本上是三维数学，包括了点，矢量，矩阵，坐标系，以及他们的运算</p><p>这些数学内容不着重描写，可以在之前计算机图形学的博客温习。</p><p>这一章会主要谈谈四元数的特点，和其他旋转表示方式的比较。</p><h2 id="4-4-四元数"><a href="#4-4-四元数" class="headerlink" title="4.4 四元数"></a>4.4 四元数</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>我们可以用3x3的矩阵来表示旋转，但旋转只有三个自由度（pitch,yaw,roll）,用9个float来表示旋转很显然是冗余的</p><p>四元数可以表达为</p><p><img src="/images/loading.jpg" data-original="/2022/03/03/2022-03-03-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E7%B2%BE%E8%A6%81%EF%BC%88%E6%89%8D%E6%80%AA%EF%BC%89%E2%91%A1/image-20220303222511659.png" alt="image-20220303222511659"></p><p>其中只有单位长度的四元数能表达三维函数（四元数算式太难打了不打了）</p><p>四元数可以理解成一个矢量一个标量，一个轴（矢量）和一个角度。</p><hr><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>四元数进行加法是不能表达旋转的，因为这样就不符合单位长度了。</p><p>给定两个四元数p和q表达旋转P和旋转Q，则pq就表示P和Q的组合旋转。</p><p>四元数求逆写为q-1（自动脑补上标-1），逆四元数和原四元数的乘积为标量1</p><p>共轭四元数q*相当于原四元数的矢量部分取负号，在单位长度的情况下，共轭四元数和逆四元数相等（）</p><p>因此计算逆四元数比计算3x3逆矩阵快很多，可以利用这一特点优化引擎。</p><p>具体和矢量的旋转运算见原书p180，任何三维旋转都可以在3x3矩阵和四元数之间随意自由转换。</p><hr><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><p>四元数对比矩阵和欧拉角最大的优越在于插值方便</p><p>四元数的插值有线性插值（LERP）和球面线性插值（SLERP）两种。</p><p>SLERP对比LERP有更准确的结果，但开销更大更加昂贵，使用哪种插值还有待商榷。</p><hr><h2 id="4-5-比较各种旋转方式"><a href="#4-5-比较各种旋转方式" class="headerlink" title="4.5 比较各种旋转方式"></a>4.5 比较各种旋转方式</h2><h3 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h3><p>欧拉角能表示旋转，由三个标量（pitch,yaw,roll）组成，会用一个三维矢量表示</p><p>优势：简单小巧（3个float），直观，便于理解，对于某个轴的插值只需要对对应的标量做插值</p><p>缺陷：对任意方向的旋转做不了插值；万向节死锁；领域没有通用的旋转次序，不能定义一个确定的旋转，旋转的先后次序对结果有影响；</p><hr><h3 id="3x3矩阵"><a href="#3x3矩阵" class="headerlink" title="3x3矩阵"></a>3x3矩阵</h3><p>3x3矩阵是有效表达旋转的方式，不受万向节死锁影响</p><p>优势：可以确切的独一无二的表达旋转，CPU和GPU有内建支持可以硬件加速运算，纯旋转的转置矩阵为逆矩阵</p><p>缺陷：旋转矩阵不够直观，不容易想象成对应的空间变换；旋转矩阵不容易插值；相对欧拉角（3个float）旋转矩阵需要9个float。</p><hr><h3 id="轴角"><a href="#轴角" class="headerlink" title="轴角"></a>轴角</h3><p>一个以单位矢量定义的旋转轴，再加上一个标量定义的旋转角</p><p>优势：直观，紧凑（4个float），确定了左右手就能确切表示旋转</p><p>缺陷：无法直接简单的进行插值，轴角形式的旋转也不能直接施加于矢量，必须转化为矩阵或四元数</p><hr><h3 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h3><p>形式与轴角相似，与轴角的区别是四元数的旋转轴矢量的长度为旋转角的一半的正弦，第四分量不是旋转角而是旋转半角的余弦。</p><p>优势：能串接旋转，可以轻易插值，只需要储存4个float，可以和矩阵自由转换，无所不能</p><p>缺陷：难学（确信）</p><hr><h1 id="第五章-游戏支持系统"><a href="#第五章-游戏支持系统" class="headerlink" title="第五章  游戏支持系统"></a>第五章  游戏支持系统</h1><h2 id="5-1-子系统的启动和终止"><a href="#5-1-子系统的启动和终止" class="headerlink" title="5.1 子系统的启动和终止"></a>5.1 子系统的启动和终止</h2><p>游戏引擎是一个复杂工程，必须按照各个系统的依赖关系进行加载和卸载。</p><hr><h3 id="c-的静态初始化（行不通哒）"><a href="#c-的静态初始化（行不通哒）" class="headerlink" title="c++的静态初始化（行不通哒）"></a>c++的静态初始化（行不通哒）</h3><p>游戏引擎大部分为c++编写，原生的启动是否可以作为启动用？</p><p>众所周知全局和静态对象是在main函数之前初始化的，我们无法预知他们构造的次序，因此是行不通的。</p><hr><h3 id="按需构建（还是行不通哒）"><a href="#按需构建（还是行不通哒）" class="headerlink" title="按需构建（还是行不通哒）"></a>按需构建（还是行不通哒）</h3><p>在c++中，类中声明的静态变量只会在第一次调用时构造，我们创建静态变量就能控制全局单例的构造次序。</p><p>但此方法无法控制析构次序，</p><hr><h3 id="在单例管理器中定义启动和终止函数（盘他）"><a href="#在单例管理器中定义启动和终止函数（盘他）" class="headerlink" title="在单例管理器中定义启动和终止函数（盘他）"></a>在单例管理器中定义启动和终止函数（盘他）</h3><p>放弃使用构造函数和析构函数，这两个函数让他们去摸鱼</p><p>我们自己定义并按所需的明确顺序调动各启动和终止函数。</p><pre><code>class RenderManager&#123;  public:   RenderManager()   &#123;      //摸鱼   &#125;   ~RenderManager()   &#123;      //摸鱼   &#125;      void startUP()   &#123;      //启动管理器   &#125;         void ShutDown()   &#123;      //终止管理器   &#125;&#125;.....class AnimationManager&#123;....&#125;//巴拉巴拉...RenderManager gRenderManager;AnimationManager gAnimationManager;//巴拉巴拉...int main()&#123;    gRenderManager.startUP();    gAnimationManager.startUP();        //运行游戏        gAnimationManager.ShutDown();    gRenderManager.ShutDown();       //以相反的次序终止各系统&#125;</code></pre><hr><h2 id="5-2-内存管理"><a href="#5-2-内存管理" class="headerlink" title="5.2 内存管理"></a>5.2 内存管理</h2><p>通过malloc和free或者new/delete来动态申请内存（堆分配），是非常慢的操作</p><p>原因是堆分配器是一个通用的设施，必须能处理任何大小的请求，需要大量管理开销（众所周知越通用的东西就越不高效越不强大）</p><p>在多数操作系统中，动态分配内存会使得从用户态切换到核心态（好耶刚刚学）</p><p>ue在内存方面是怎么处理的则在另一篇博客新坑有比较详细的说明</p><hr><h3 id="基于堆的分配器"><a href="#基于堆的分配器" class="headerlink" title="基于堆的分配器"></a>基于堆的分配器</h3><p>分配一大段连续内存，安排一个指向堆顶部的指针，用来标识已分配的和未分配的空间</p><p>进行分配时，只需要把指针往上移动请求所需的字节数即可。释放空间时，记得以进行分配时相反的次序进行释放</p><p>可以编写一个函数，把堆顶指针回滚到上一次标记的位置，即释放回滚点之后到堆顶的所有内存</p><p>伪代码可以在原书p220查看</p><hr><h3 id="双端堆分配器"><a href="#双端堆分配器" class="headerlink" title="双端堆分配器"></a>双端堆分配器</h3><p>将一块内存给两个分配器使用，一个从底端向上分配，另一个从顶端向下分配。</p><p>这个方案很实用，因为允许权衡两个堆栈的使用，因此能更有效的运用内存。</p><hr><h3 id="池分配器"><a href="#池分配器" class="headerlink" title="池分配器"></a>池分配器</h3><p>在分配大量同等大小的小块内存时（矩阵，迭代器，可渲染的网格实例），池分配器则是不二之选。</p><p>做法是预先分配一大块内存，大小刚好是元素分配内存大小的倍数。</p><p>例如4x4矩阵池就是16个元素乘以每个元素4字节（32位float）或8字节（64位double）。</p><p>（ps：原书的意思应该是这个池本身是一个4x4矩阵的形状，用来存放16个元素，而非储存一个4x4矩阵）</p><p>收到分配请求时只需要取出元素，释放则只需要回收回池中，分配和释放都是O(1)的操作。</p><hr><h3 id="含对齐功能的分配器"><a href="#含对齐功能的分配器" class="headerlink" title="含对齐功能的分配器"></a>含对齐功能的分配器</h3><p>所有内存分配器都传回对齐的内存块（具体实现伪代码在原书p223有详解）</p><p>对齐的内存块能让CPU更加高效的读写。</p><hr><h3 id="单帧和双缓冲内存分配器"><a href="#单帧和双缓冲内存分配器" class="headerlink" title="单帧和双缓冲内存分配器"></a>单帧和双缓冲内存分配器</h3><p>几乎引擎都会在游戏循环中分配一些临时用的数据，要么在这次循环中丢弃，要么在下一次迭代丢弃。</p><p><strong>单帧分配器</strong>的做法是先预留一块内存，并以前文所述的基于堆的分配器分配，在每一帧开始时将顶端指针重新定向到内存块的底端地址。</p><p>益处是分配的这块内存永远会在循环中重置，不需要我们手动释放，也极其高效</p><p>但我们必须注意决不能将指向单帧内存块的指针跨帧使用（nullptr警告）</p><p><strong>双缓冲分配器</strong>允许在第i帧分配的内存块用于i+1帧，实现则是简历两个相同尺寸的单帧堆分配器，每帧交替使用</p><p>在缓存非同步处理的结果时，这类分配器极其有用。双缓冲模式在渲染里因为可以解决画面撕裂的问题得到了广泛应用</p><p>我们在当帧完成前将结果写入缓存，在下一帧时缓冲处于不活跃状态，我们依然可以安心使用数据。</p><hr><p>今天看到内存管理的部分就没怎么看了，原因是和糕糕老师聊ue的内存管理这部分聊了很多有意思的东西，一不注意时间就过去了。</p><p>不过感觉今天收获还是不少滴，吸收的也还可以，日后想动手自己实现一个内存管理方案了。2022/3/3</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《Game Engine Architecture》是一直以来我很有兴趣也很想阅读的书，书的译者是我很敬重的milo叶劲峰前辈（魔方引擎中心的大大）。&lt;/p&gt;
&lt;p&gt;但是由于自己基础不牢，再加上这本厚厚的大书所带来的畏难情绪，同时自己过于功利总是把时间抽去做容易提升的事情，&lt;/p&gt;
&lt;p&gt;以及n个自己给自己找的理由，让这个阅读计划一直搁置。&lt;/p&gt;
&lt;p&gt;但这学期拿到了暑期实习的offer，刚巧也在魔方，对于就业的压力就减小了很多&lt;/p&gt;
&lt;p&gt;再加上自己有意往引擎方向发展，阅读这本书就提上了日程。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>游戏引擎架构精要（才怪）①</title>
    <link href="https://aprilnavi.github.io/2022/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E7%B2%BE%E8%A6%81%EF%BC%88%E6%89%8D%E6%80%AA%EF%BC%89%E2%91%A0/"/>
    <id>https://aprilnavi.github.io/2022/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E7%B2%BE%E8%A6%81%EF%BC%88%E6%89%8D%E6%80%AA%EF%BC%89%E2%91%A0/</id>
    <published>2022-03-01T13:36:58.000Z</published>
    <updated>2022-03-03T13:04:20.103Z</updated>
    
    <content type="html"><![CDATA[<p>《Game Engine Architecture》是一直以来我很有兴趣也很想阅读的书，书的译者是我很敬重的milo叶劲峰前辈（魔方引擎中心的大大）。</p><p>但是由于自己基础不牢，再加上这本厚厚的大书所带来的畏难情绪，同时自己过于功利总是把时间抽去做容易提升的事情，</p><p>以及n个自己给自己找的理由，让这个阅读计划一直搁置。</p><p>但这学期拿到了暑期实习的offer，刚巧也在魔方，对于就业的压力就减小了很多</p><p>再加上自己有意往引擎方向发展，阅读这本书就提上了日程。</p><span id="more"></span><p>既然它这么厚，那囫囵吞枣看完就忘肯定都是不行的，所以还是写点东西记一下吧</p><p>之前有粗读一下这本书，书的内容是复杂，综合，全面的，每个章节都涵盖了大量的内容</p><p>以目前的能力没法很好的概括提及，没有像之前记录《游戏编程模式》那样有固定的写作框架</p><p>所以这篇博客的形式可能还是更倾向读书笔记而非对他人有意义的知识总结</p><p>所以现在这些废话基本上是写给自己看的hhh</p><hr><h1 id="第一章-基础"><a href="#第一章-基础" class="headerlink" title="第一章  基础"></a>第一章  基础</h1><p>导论，游戏介绍，不同游戏类型所使用的引擎差异，游戏引擎概述，没什么好说的，工具及资产管道，略</p><p><img src="/images/loading.jpg" data-original="/2022/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E7%B2%BE%E8%A6%81%EF%BC%88%E6%89%8D%E6%80%AA%EF%BC%89%E2%91%A0/VDMX@PP27ZW40Z1U9O%257XC.png" alt="img"></p><p>第一章里面感觉这张图既经典又重要，丢一篇米忽悠大佬的文</p><p><a href="https://zhuanlan.zhihu.com/p/356028087">从零手写游戏引擎2：引擎架构概述 - 知乎 (zhihu.com)</a></p><p>大佬评价这本书游戏开发领域尤其是客户端开发必看书籍，也是一本偏入门和科普性质的书籍。</p><p>看来这个入门还是让我蛮吃力的hhh。</p><hr><h1 id="第二章-专业工具"><a href="#第二章-专业工具" class="headerlink" title="第二章  专业工具"></a>第二章  专业工具</h1><h2 id="2-1-版本控制"><a href="#2-1-版本控制" class="headerlink" title="2.1 版本控制"></a>2.1 版本控制</h2><p>git，会用就行，命令行要用再查，略</p><h2 id="2-2-visual-studio常见功能"><a href="#2-2-visual-studio常见功能" class="headerlink" title="2.2 visual studio常见功能"></a>2.2 visual studio常见功能</h2><h3 id="生成配置"><a href="#生成配置" class="headerlink" title="生成配置"></a>生成配置</h3><p><img src="/images/loading.jpg" data-original="/2022/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E7%B2%BE%E8%A6%81%EF%BC%88%E6%89%8D%E6%80%AA%EF%BC%89%E2%91%A0/image-20220301203453167.png" alt="image-20220301203453167"></p><p>可以在生成配置里面设定不同的预处理器，编译器，链接器属性</p><p><strong>预处理器设置</strong>处理#include文件的展开，以及处理#define宏的定义和替换</p><p><strong>编译器设置</strong>控制产生的对象文件是否包含调试信息，是最常见的编译选项之一，也可以控制是否展开内联函数。</p><p><strong>链接器设置</strong>指定将哪些外部库链接到可执行文件，以及搜索路径</p><p>一般项目自带”调试（debug）“和”发布（release）“配置。</p><h3 id="常规属性页设置"><a href="#常规属性页设置" class="headerlink" title="常规属性页设置"></a>常规属性页设置</h3><p>随便打开一个项目的属性就能进入常规属性设置页面，里面有输出目录，中间目录各种目录的说明。</p><h3 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h3><p>我一直觉得调试代码是很重要的功能，希望可以借着记录要点和操作慢慢理解增进</p><ul><li><p>一个解决方案可能包含多个项目，记得正确设置启动项目。</p></li><li><p>断点（breakpoint）是代码调试的基本所需，能让代码停下观察此刻的运行状态。</p></li><li><p>F5 开始调试，F10 逐过程运行（不进入函数调用），F11 逐语句运行（进入函数调用）</p></li></ul><p><img src="/images/loading.jpg" data-original="/2022/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E7%B2%BE%E8%A6%81%EF%BC%88%E6%89%8D%E6%80%AA%EF%BC%89%E2%91%A0/image-20220301210551736.png" alt="image-20220301210551736"></p><p><img src="/images/loading.jpg" data-original="/2022/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E7%B2%BE%E8%A6%81%EF%BC%88%E6%89%8D%E6%80%AA%EF%BC%89%E2%91%A0/image-20220301210657028.png" alt="image-20220301210657028"></p><p>运行中可以如图所示调出许多窗口用于观察变量或者变量地址，函数堆栈情况。</p><p>其中监视窗口是个很有意思的功能，有机会可以多多尝试。</p><p>数据断点也是个很有用的功能，可以在指定地址或者被写入时引发一个中断</p><p>（vs2022没有找到条件断点，但找到了函数断点）</p><p><img src="/images/loading.jpg" data-original="/2022/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E7%B2%BE%E8%A6%81%EF%BC%88%E6%89%8D%E6%80%AA%EF%BC%89%E2%91%A0/image-20220301211906610.png" alt="image-20220301211906610"></p><h2 id="2-3-剖析工具"><a href="#2-3-剖析工具" class="headerlink" title="2.3 剖析工具"></a>2.3 剖析工具</h2><p>剖析器（profiler）可以度量代码的执行时间，并能告知每个函数所花的时间。</p><ul><li>统计式剖析器：几乎不影响目标代码的执行速度，原理是周期为CPU的程序计数器寄存器进行采样。</li><li>测控式剖析器：提供最详细最精确的计时数据，代码几乎跑不动。</li></ul><hr><h1 id="第三章-游戏软件工程基础"><a href="#第三章-游戏软件工程基础" class="headerlink" title="第三章  游戏软件工程基础"></a>第三章  游戏软件工程基础</h1><p>3.1说的是cpp的语法以及cpp11的一些特性</p><p>3.2则聊了聊一些比较深的东西，例如多态和虚函数表，拷贝和移动语义，内存布局</p><p>这些内容早在背八股文的时候都记牢了也理解了，没有什么有意思的内容</p><h2 id="3-3-捕捉和错误处理"><a href="#3-3-捕捉和错误处理" class="headerlink" title="3.3 捕捉和错误处理"></a>3.3 捕捉和错误处理</h2><p>错误分为用户错误和程序员错误，用户错误指用户做了不正确的事情引发的错误</p><p>例如无效键入，尝试打开不存在的文件，我们这里只讨论程序员错误。</p><p>程序员错误的处理应该以立即中止程序并提供调试信息为原则。</p><ul><li><p>错误返回码：当函数执行错误时返回一个不可能的值，最好可以返回一个枚举值。缺点是堆栈里的函数观察到错误时，其他函数都要添加代码。</p></li><li><p>异常：可以检测错误函数，并把相关错误储存于某对象，缺点是异常处理会有一些额外的开销，一个函数使用了异常整个程序都得使用异常。</p></li><li><p>断言：当表达式为假时，暂停程序打印错误信息。断言可以用宏实现，UE引擎则自带断言功能。</p></li></ul><p>3.4说的是流水线，缓存以及优化，这些涉及到硬件架构的内容目前对我来说太硬核了，往后稍稍。</p><hr><p>今天就到这里吧，第四章基本上都是三维数学相关的内容，里面矢量，矩阵，坐标系那些的内容也是基本上滚瓜烂熟了</p><p>第四章中比较感兴趣的是四元数，奈何今天看到的时候没看明白233333</p><p>2022.3.1 ——21：32</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;《Game Engine Architecture》是一直以来我很有兴趣也很想阅读的书，书的译者是我很敬重的milo叶劲峰前辈（魔方引擎中心的大大）。&lt;/p&gt;
&lt;p&gt;但是由于自己基础不牢，再加上这本厚厚的大书所带来的畏难情绪，同时自己过于功利总是把时间抽去做容易提升的事情，&lt;/p&gt;
&lt;p&gt;以及n个自己给自己找的理由，让这个阅读计划一直搁置。&lt;/p&gt;
&lt;p&gt;但这学期拿到了暑期实习的offer，刚巧也在魔方，对于就业的压力就减小了很多&lt;/p&gt;
&lt;p&gt;再加上自己有意往引擎方向发展，阅读这本书就提上了日程。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>第二周学习日志（log for touching fish）</title>
    <link href="https://aprilnavi.github.io/2022/02/28/%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    <id>https://aprilnavi.github.io/2022/02/28/%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</id>
    <published>2022-02-28T04:31:47.000Z</published>
    <updated>2022-03-04T12:03:40.236Z</updated>
    
    <content type="html"><![CDATA[<p>开学啦开学啦</p><span id="more"></span><h2 id="Monday"><a href="#Monday" class="headerlink" title="Monday"></a>Monday</h2><p>早上算是效率还不错的，虽然其实做了并没有特别多的事情</p><p>我想想好像成功导入了imgui的库跑起来了，找了个光酱的obj渲了出来</p><p>虽然具体怎么运行还需要再研究研究，但明天不打算花时间了，周末有时间再看看吧</p><p>这样想想其实并没有做什么事，但好在人的精神很好，心情也不错，</p><p>初学渲染的时候总是这样充满精神的，这样让我觉得正反馈很强。</p><hr><p>下午去图书馆看了引擎架构，一边聊天一边摸鱼看书，心情还是不错的</p><p>目前为止有些计算机硬件的东西看不明白但感觉应该对我目前不太重要</p><p>有些关于vs调试的知识感觉对我确实不错，之后可能会出篇博客记录一下</p><p>下午看到3.7要补考软测了，爷tx实习都拿了还要补考真是醉了555</p><hr><p>晚上开始有点迷茫了吧，得失心还是太重了。</p><p>每当学习一段时间如果没能感到进步或者有学到知识</p><p>不免就会觉得浪费了时间而感到焦虑。</p><p>而迄今为止依然没有找到学习虚幻4的好办法</p><p>国内没有一个系统的教科书的教程供高效学习，同时自己的实操能力也很差</p><p>可能更偏向传统的一步一步带着走的教程而非开源资源教学</p><p>再加上自己也想好好的研究下UE引擎的源码还有其他方面的东西</p><p>不免觉得自己的脑子犹如石沉大海，感觉这方面就算手搓了个demo也还是个新手</p><p>要学的东西太多了||同学比我厉害看的书比我多||转正要做MiniGame但我gameplay半桶水</p><p>但好在每当我开始写作，心情就会好起来。待会再去肝会xb2吧，反正其他人不也都在老头环23333。</p><hr><h2 id="Tuesday"><a href="#Tuesday" class="headerlink" title="Tuesday"></a>Tuesday</h2><p>虽然昨天两点才睡，但早上精神依旧很好</p><p>第一节课改geometry给hikari酱做了一个法线可视化，就像毛毛人一样</p><p>也印证了assimp的法线导入是没问题的，有机会把之前项目改改重新做吧</p><p>随后是做instancing章节做到一半，后边会渲出一个实时旋转的行星带场景</p><p>还是挺让人期待的，明天上午没课就做这个吧（熬夜打xb睡很晚也有可能）</p><p>第二节课猛看os，感觉os基本上掌握就只是时间问题</p><hr><p>中午打原神打到忘记午睡了，下午第一节课看了会os就趴桌上睡了</p><p>醒来看了线程进程，摸了会鱼玩手机和ieg的前辈姐姐聊了聊时间就过了</p><p>后边去图书馆遇到了班里的很多老熟人，这两天听身边同学耳闻也基本上开始面试找工作了</p><p>发现班里努力的人还是不少的（虽然总是那几个），不过大三下了这是理所当然的</p><p>总是觉得能拿到魔方offer然后兴趣驱动学习的自己真幸运</p><p>还是要一步一步脚踏实地的来，走好每一步路珍惜这个机会</p><p>下午看引擎架构基本上看在了三维数学上，就看了一个多小时六七十页的样子</p><p>五点想着回宿舍记录一下博客吧，接着就凹了两个小时的分。</p><p>不得不说写作真的是正反馈很强的事情，单单看着那堆字就成就感爆棚</p><p>每当学习遇到瓶颈心态失衡的时候，如果不想开摆直接打游戏的话，</p><p>记录一下近期学习的近况也记录一下心情，确实是个很不错的主意</p><p>希望今晚的学习历程一切顺利吧。</p><hr><h2 id="Wednesday"><a href="#Wednesday" class="headerlink" title="Wednesday"></a>Wednesday</h2><p>我的天，昨天忘记记了，写这个已经是周四了</p><p>说起来这周要补考我到现在还没复习也没打印准考证呜呜呜（闲话到此为止！）</p><p>说起来早上没课，感觉想摆一摆，于是就打了一早上深渊，</p><p>打到十一点糕糕老师叫我去A然后我又A到了快亮点</p><p>想了想必须喝杯咖啡赶紧做事了</p><hr><p>这样想想也没有做多少事情</p><p>下午我则是把玩了instancing渲染把玩了很久</p><p>只要是同一个相同的物体在场景里面渲染</p><p>使用instancing渲染就可以用同一个shader减少draw call的次数</p><p>最后渲染了100w个小行星，GPU直接跑满电脑狂转hhh</p><p>接着就是和糕糕老师一边聊ue的一些特性一边做gameplay</p><p>一开始看ue的api感觉是懵的，因为很久没有接触了（别骂了）</p><p>后边感觉手感恢复了很多，做了个黑洞吸东西的功能</p><p>没怎么想就直接做出来了，算是没那么坐牢了</p><hr><p>但是昨天实在太摸鱼了，被刚刚下班的引擎的前辈训斥了</p><p>“刚刚下班就看见你在高强度水群，别水了我都替你着急！”</p><p>呜呜呜瞬间感觉弱小又愧疚，虽然绝对而言我就业可能压力不大</p><p>但在腾讯的23届里面实力我绝对是垫底的，因此确实很珍惜实习生的机会</p><p>因为版号原因，接下来hc会更少的吧，想进大厂基本上也就只有校招这个机会了</p><p>所以感觉压力还是挺大的，昨天做到了十二点才下，做完也没打游戏直接就下了</p><p>希望2022年能有不错的提升，我看那些大我一届的前辈不是在搞神经渲染就是在手写引擎</p><p>一个个全都爆杀我，不过我相信自己的潜力是无穷的！</p><p>（相信的心就是你的魔法）</p><hr><h2 id="Thursday"><a href="#Thursday" class="headerlink" title="Thursday"></a>Thursday</h2><p>对不起我忘记写了完全想不起来了</p><h2 id="Friday"><a href="#Friday" class="headerlink" title="Friday"></a>Friday</h2><p>上午带电脑去教室边摸鱼边做，最后还好是成功把离屏msaa做出来了（摸鱼指打原神）</p><p>（是真的做出来了哦，不是碰巧结果和我做的相似哦）</p><p>中午和糕糕前辈A到了两点，玩了会ns开摆睡到四点半，背电脑到图书馆就是五点了</p><p>于是一直效率爆棚的肝博客肝到了现在（世末歌者是真的好听我超）</p><p>不得不说听歌抖腿效率码字的效率是真的高啊</p><p>写了一篇学习抗锯齿方案的博客，现在在写平时请教年糕前辈的记录</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开学啦开学啦&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>如何用OpenGL复现Phong模型</title>
    <link href="https://aprilnavi.github.io/2022/01/23/%E5%A6%82%E4%BD%95%E7%94%A8OpenGL%E5%A4%8D%E7%8E%B0phong%E6%A8%A1%E5%9E%8B/"/>
    <id>https://aprilnavi.github.io/2022/01/23/%E5%A6%82%E4%BD%95%E7%94%A8OpenGL%E5%A4%8D%E7%8E%B0phong%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-01-23T11:36:58.000Z</published>
    <updated>2022-01-24T15:25:23.473Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇博客的时候我还在我老家的床上，给自己放了两三天的假，决定写点东西。</p><p>在经历了visual studio的链接失败和着色器编译失败之后</p><p>深感自己力量渺小，无法棒打vs设计师（胡言乱语）</p><p>再加上之前学的有些快而不扎实，复制源码跑动了看一遍就粗略带过（有时甚至跑不动）</p><p>所以写这篇救命博客来挽救一下自己岌岌可危的大脑。</p><span id="more"></span><p><img src="/images/loading.jpg" data-original="/2022/01/23/%E5%A6%82%E4%BD%95%E7%94%A8OpenGL%E5%A4%8D%E7%8E%B0phong%E6%A8%A1%E5%9E%8B/QQ%E5%9B%BE%E7%89%8720220123213125.png" alt="QQ图片20220123213125.png"></p><hr><p>首先先祝贺自己拿到了魔方的暑期实习，已经踏上正轨了但还需努力，毕竟能不能转正，还得看今后发展的如何。但我其实更想从事引擎方面的工作。</p><hr><p>OpenGL的教程是鼎鼎大名的learnOpenGL，中文站做了很棒的翻译工作，强烈安利。</p><p>代码中涉及到封装的函数，类，因为并不重要所以就不予展示。</p><p>更多的是自己温习一个完整OGL渲染程序的不同模块。</p><p>首先让我打开vs找找我的源码，哦对这样可能废话有点多</p><p>但我喜欢这样诙谐的语气记录自己想法，毕竟最后看到这个博客的可能只有我一个人</p><p>总而言之，让我们先看看如何创建一个窗口吧。</p><hr><h2 id="创建窗口部分"><a href="#创建窗口部分" class="headerlink" title="创建窗口部分"></a>创建窗口部分</h2><p>先丢源码，使用的是我们的<strong>寄了废物库</strong>和<strong>glad库</strong>，glad库能让我们更方便的在运行时确定函数地址</p><p>这些代码可以让我们创建一个窗口</p><pre><code class="c++">#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;int main()&#123;    glfwInit();//初始化    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);//主版本号    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);//副版本号    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);//核心渲染模式#ifdef __APPLE__    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif    // glfw window creation    // --------------------    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, &quot;Render Window&quot;, NULL, NULL);//new一个窗口对象    if (window == NULL)    &#123;        std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;        glfwTerminate();        return -1;    &#125;    glfwMakeContextCurrent(window);    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);//绑定窗口回调函数    glfwSetCursorPosCallback(window, mouse_callback);//绑定鼠标移动视野的函数    glfwSetScrollCallback(window, scroll_callback);//绑定滚轮回调函数    // tell GLFW to capture our mouse    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);//捕获鼠标    // glad: load all OpenGL function pointers    // ---------------------------------------    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))        //给GLAD传入了用来加载系统相关的OpenGL函数指针地址的函数    &#123;        std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl;        return -1;    &#125;        ....        //渲染循环    while(!glfwWindowShouldClose(window)) &#123;    ....             processInput(window);//处理输入逻辑    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);//设置清除缓冲的颜色    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);用这个颜色来清除缓冲，顺便也清除深处缓冲            ....               glfwSwapBuffers(window);//交换帧缓冲    glfwPollEvents();//检查并处理各个事件 &#125;        glfwTerminate();    return 0;&#125;</code></pre><p>通过这些代码，应该可以直接创建出一个渲染窗口。</p><hr><p>突然间有点不知道怎么组织复述各个模块了哈哈</p><hr><h2 id="顶点数据"><a href="#顶点数据" class="headerlink" title="顶点数据"></a>顶点数据</h2><p>这里涉及到VAO，VBO，EBO（这里没用到）的概念</p><p>详细了解这三个的概念可以看<a href="https://blog.csdn.net/qq_32974399/article/details/103956589">详解Opengl中VBO和VAO_代码乐的博客-CSDN博客_opengl vao</a></p><p>一言蔽之，vbo<strong>存数据</strong>，vao<strong>存配置信息</strong>，一般先绑vao，然后再把其他东西往上绑</p><p>vao也会把存入的vbo记上，用的时候用vao就行，东西都设置完了最后解绑vao。</p><pre><code class="c++">    float vertices[] = &#123;        // positions          // normals           // texture coords        -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  0.0f,  0.0f,         0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  1.0f,  0.0f,         0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  1.0f,  1.0f,         0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  1.0f,  1.0f,        -0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  0.0f,  1.0f,        -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  0.0f,  0.0f,        -0.5f, -0.5f,  0.5f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,         0.5f, -0.5f,  0.5f,  0.0f,  0.0f,  1.0f,  1.0f,  0.0f,         0.5f,  0.5f,  0.5f,  0.0f,  0.0f,  1.0f,  1.0f,  1.0f,         0.5f,  0.5f,  0.5f,  0.0f,  0.0f,  1.0f,  1.0f,  1.0f,        -0.5f,  0.5f,  0.5f,  0.0f,  0.0f,  1.0f,  0.0f,  1.0f,        -0.5f, -0.5f,  0.5f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,        -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,  1.0f,  0.0f,        -0.5f,  0.5f, -0.5f, -1.0f,  0.0f,  0.0f,  1.0f,  1.0f,        -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,  0.0f,  1.0f,        -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,  0.0f,  1.0f,        -0.5f, -0.5f,  0.5f, -1.0f,  0.0f,  0.0f,  0.0f,  0.0f,        -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,  1.0f,  0.0f,         0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,  1.0f,  0.0f,         0.5f,  0.5f, -0.5f,  1.0f,  0.0f,  0.0f,  1.0f,  1.0f,         0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,  0.0f,  1.0f,         0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,  0.0f,  1.0f,         0.5f, -0.5f,  0.5f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,         0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,  1.0f,  0.0f,        -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,  0.0f,  1.0f,         0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,  1.0f,  1.0f,         0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,  1.0f,  0.0f,         0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,  1.0f,  0.0f,        -0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,  0.0f,  0.0f,        -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,  0.0f,  1.0f,        -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,  0.0f,  1.0f,         0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,  1.0f,  1.0f,         0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,  1.0f,  0.0f,         0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,  1.0f,  0.0f,        -0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,        -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,  0.0f,  1.0f    &#125;;//顶点数据，可以不看，但得写出来知道是做什么的    unsigned int VBO, cubeVAO;//生成这俩ID，其中的这个vao是用来管理我们渲染的箱子的    glGenVertexArrays(1, &amp;cubeVAO);//用这个ID生成顶点数组，反正vao就用的这玩意    glGenBuffers(1, &amp;VBO);//用这个ID生成缓冲，是缓冲哦，vbo用这种缓冲，待会其他缓冲也得用这个    glBindBuffer(GL_ARRAY_BUFFER, VBO);//把这份缓冲绑定到显存的那部分真正的缓冲上    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);//往显存上开始写入顶点数据    glBindVertexArray(cubeVAO);//先把vao绑上，之后配置的各种数据vao都会记录下来    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);    glEnableVertexAttribArray(0);    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));    glEnableVertexAttribArray(1);    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));    glEnableVertexAttribArray(2);//指定着色器怎么解析顶点数据，在下文细说    unsigned int lightCubeVAO;//这是另一个vao哦，这个vao用来管理我们的光源    glGenVertexArrays(1, &amp;lightCubeVAO);//一样的用ID生成    glBindVertexArray(lightCubeVAO);//一样的绑定vao    glBindBuffer(GL_ARRAY_BUFFER, VBO);//一样的绑定缓存，之前把顶点数据写入过一次这次就不写了    // note that we update the lamp&#39;s position attribute&#39;s stride to reflect the updated buffer data    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);    glEnableVertexAttribArray(0);//指定着色器怎么解析顶点数据....    while (!glfwWindowShouldClose(window))    &#123;        ...        lightingShader.use();        //使用被渲染的箱子的着色器程序        ...        //渲染箱子        glBindVertexArray(cubeVAO);//使用这套vao来渲染，vao里面包括了设置好的vbo和配置信息        glDrawArrays(GL_TRIANGLES, 0, 36);//画36个顶点，以画三角形的方式        ...                //使用光源的着色器程序        lightCubeShader.use();        ...        //渲染光源        glBindVertexArray(lightCubeVAO);//同上，不过这个是光源        glDrawArrays(GL_TRIANGLES, 0, 36);                ...    &#125;....    //渲染完成后删除这些数据释放资源    glDeleteVertexArrays(1, &amp;cubeVAO);    glDeleteVertexArrays(1, &amp;lightCubeVAO);    glDeleteBuffers(1, &amp;VBO);</code></pre><p>glGenBuffers和glGenVertexArrays的作用有点像我们new一份空间，然后就用我们指定的指针来管理这份空间一样。</p><p>然后我们再把这份生成的缓存绑定到显存的缓存上，往这份缓存写数据就是往显存写数据。</p><p>VertexArrays就直接绑着就完事了，不用管他，他会自动记录我们做过的事情。</p><hr><p>你应该记得我们的顶点数据一行有八个数据，他们有的是顶点，有的是法线，有的是纹理坐标。</p><p>接着我们是怎么指定着色器来解析数据的呢，还记得这些代码吧</p><pre><code>    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);    glEnableVertexAttribArray(0);    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));    glEnableVertexAttribArray(1);    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));    glEnableVertexAttribArray(2);</code></pre><p>接着让我们看看我们的顶点着色器是怎么导入数据的吧。</p><pre><code>#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aNormal;layout (location = 2) in vec2 aTexCoords;</code></pre><p>我们指定了三个不同的位置来导入我们的顶点数据</p><p><code>glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);</code></p><p>所做的就是指定顶点着色器的0号位置，3个值，浮点数，一份顶点数据有8个值，我们从偏移量0的开始算</p><p><code>    glEnableVertexAttribArray(0);</code>启用0号顶点数据</p><p>然后我们两个vao分别是所渲染箱子和光源的数据，他们都用的同一套顶点数据（都是正方体）</p><p>但第二个vao只要顶点数据就够了。我们对于两个vao使用不同的shader程序来渲染。</p><hr><h2 id="导入纹理"><a href="#导入纹理" class="headerlink" title="导入纹理"></a>导入纹理</h2><p>导入纹理这块我们用了一个函数来封装，包括怎么从文件读取，设置什么样的环绕方式和过滤方式。</p><p>stb_image.h是一个非常流行的单头文件图像加载库，它能够加载大部分流行的文件格式，并且能够很简单得整合到工程之中。</p><pre><code class="c++">#define STB_IMAGE_IMPLEMENTATION//没加这个宏直接把我害死，编译就一个劲链接错误#include &quot;stb_image.h&quot; //这个头文件glEnable(GL_DEPTH_TEST);//既然提到纹理就记得开启深度测试，要不然会很哈人unsigned int diffuseMap = loadTexture(&quot;container2.png&quot;);unsigned int loadTexture(char const* path)&#123;    unsigned int textureID; //定义一个纹理的ID    glGenTextures(1, &amp;textureID);//生成一个纹理数据，就像上边顶点数据一样    int width, height, nrComponents;//长，宽，颜色通道个数    unsigned char* data = stbi_load(path, &amp;width, &amp;height, &amp;nrComponents, 0);    if (data)    &#123;        GLenum format;//根据颜色通道个数选择纹理格式        if (nrComponents == 1)            format = GL_RED;        else if (nrComponents == 3)            format = GL_RGB;        else if (nrComponents == 4)            format = GL_RGBA;        glBindTexture(GL_TEXTURE_2D, textureID);//在显存上绑定纹理        glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);        //第一个参数指定了纹理目标(Target)。设置为GL_TEXTURE_2D意味着会生成与当前绑定的纹理对象在同一个目标上的纹理（任何绑定到GL_TEXTURE_1D和GL_TEXTURE_3D的纹理不会受到影响）。        //第二个参数为纹理指定多级渐远纹理的级别，如果你希望单独手动设置每个多级渐远纹理的级别的话。这里我们填0，也就是基本级别。        //第三个参数告诉OpenGL我们希望把纹理储存为何种格式。        //第四个和第五个参数设置最终的纹理的宽度和高度。我们之前加载图像的时候储存了它们，所以我们使用对应的变量。        //下个参数应该总是被设为0（历史遗留的问题）。        //第七第八个参数定义了源图的格式和数据类型。我们使用RGB值加载这个图像，并把它们储存为char(byte)数组，我们将会传入对应值。最后一个参数是真正的图像数据。        glGenerateMipmap(GL_TEXTURE_2D);//自动生成mipmap        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);        //对于横轴和纵轴采取GL_REPEAT的环绕方式                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);        //设置过滤方式，这里我们都设为线性滤波        //一个常见的错误是，将放大过滤的选项设置为mipmap选项之一。这样没有任何效果，因为mipmap主要是使用在纹理被缩小的情况下的        stbi_image_free(data);//设置完这块纹理后我们就释放这部分数据    &#125;    else    &#123;        std::cout &lt;&lt; &quot;Texture failed to load at path: &quot; &lt;&lt; path &lt;&lt; std::endl;        stbi_image_free(data);    &#125;    return textureID;//最后我们返回一个纹理ID供我们使用&#125;    while (!glfwWindowShouldClose(window))    &#123;        ...                    lightingShader.use();        glActiveTexture(GL_TEXTURE0);        glBindTexture(GL_TEXTURE_2D, diffuseMap);        //记得在调用glDrawElements之前绑定纹理了，它会自动把纹理赋值给片段着色器的采样器：                    ...    &#125;</code></pre><p>前边部分注释写在代码里没什么好说的，让我们看看片元着色器的导入</p><pre><code>#version 330 coreout vec4 FragColor;struct Material &#123;    sampler2D diffuse;    vec3 specular;        float shininess;&#125;; ...uniform Material material;...int main&#123;   ...&#125;</code></pre><p>你可能会奇怪为什么<code>sampler2D</code>变量是个uniform，我们却不用glUniform给它赋值。</p><p>使用glUniform，我们可以给纹理采样器分配一个位置值,一个纹理的位置值通常称为一个纹理单元(Texture Unit)。</p><p>一个纹理的默认纹理单元是0，它是默认的激活纹理单元。</p><p>只要我们首先激活对应的纹理单元，不用glUniform我们也能用<code>glBindTexture(GL_TEXTURE_2D, texture);</code>将纹理传入着色器</p><p>如果有两个纹理的话，就是这样：</p><p>(这时我们就得手动设置着色器的哪个texture对应源程序代码段的哪个texture)</p><pre><code>glActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_2D, texture1);glActiveTexture(GL_TEXTURE1);glBindTexture(GL_TEXTURE_2D, texture2);...ourShader.use(); // 不要忘记在设置uniform变量之前激活着色器程序！glUniform1i(glGetUniformLocation(ourShader.ID, &quot;texture1&quot;), 0); // 手动设置ourShader.setInt(&quot;texture2&quot;, 1); // 或者使用着色器类设置while(...) &#123;    [...]&#125;</code></pre><pre><code>#version 330 core...uniform sampler2D texture1;uniform sampler2D texture2;</code></pre><p>因为OpenGL要求y轴<code>0.0</code>坐标是在图片的底部的，但是图片的y轴<code>0.0</code>坐标通常在顶部。</p><p>所以我们还能使用<code>stbi_set_flip_vertically_on_load(true);</code>翻转图片。</p><h2 id="MVP变换"><a href="#MVP变换" class="headerlink" title="MVP变换"></a>MVP变换</h2><p>还记得顶点着色器的职责吧，我们把三维的顶点数据转化成他们在屏幕上的坐标。</p><p>所以MVP变换一般由顶点着色器做运算。</p><p>我们的思路是用glm生成矩阵，然后用uniform传入着色器</p><pre><code>#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;...int main&#123;        // view/projection transformations        glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH /     (float)SCR_HEIGHT, 0.1f, 100.0f);//透视投影矩阵        glm::mat4 view = camera.GetViewMatrix();//视点变换        lightingShader.setMat4(&quot;projection&quot;, projection);        lightingShader.setMat4(&quot;view&quot;, view);        // world transformation        glm::mat4 model = glm::mat4(1.0f);//模型变换矩阵        lightingShader.setMat4(&quot;model&quot;, model);&#125;</code></pre><p>我们这里只展示了被渲染箱子的着色部分，不过这样就够了。</p><p>实际上我们渲染的另一个物体是个亮方块，他虽然是扮演了光源但实际上并没有起到太阳的作用</p><p>光线的数据依然是我们手动导入的，其他很多值都是我们规定的，</p><p>但把他以白色渲染出来可以更加直观的观察到光照是如何影响物体的</p><p>让我们复习一下mvp变换做的事情吧（肯定会有人说哎呀烦死了）</p><p><strong>模型变换（model）</strong>把顶点的坐标从局部坐标系转换到世界坐标。</p><p><strong>视点变换（view）</strong>世界坐标 &gt;&gt;&gt; 观察空间</p><p><strong>投影变换（projection）</strong>观察空间&gt;&gt;&gt;剪裁空间</p><p>观察空间经常被人们称之OpenGL的摄像机(Camera)，所以我们这里用camera类生成view矩阵，但不深究</p><p>来模拟摄像机的效果，利用wasd和鼠标可以随意遨游在我们构建的世界。</p><p>做完投影变换就直接到剪裁空间了，OpenGL然后对<strong>裁剪坐标</strong>执行<strong>透视除法</strong>从而将它们变换到<strong>标准化设备坐标</strong></p><p>在顶点着色器则里边是这样的</p><pre><code class="c++">#version 330 corelayout (location = 0) in vec3 aPos;...uniform mat4 model;uniform mat4 view;uniform mat4 projection;...    void main()&#123;    FragPos = vec3(model * vec4(aPos, 1.0));    ...    gl_Position = projection * view * vec4(FragPos, 1.0);&#125;</code></pre><p>如果不讨论怎么法线和纹理的计算，顶点着色器所做的内容就是将传入的顶点数据进行mvp变换</p><p>ps：我们这里还需要输出世界坐标系的顶点坐标进行后续运算，所以将计算分开了。</p><hr><h2 id="phong模型计算（着色器详解）"><a href="#phong模型计算（着色器详解）" class="headerlink" title="phong模型计算（着色器详解）"></a>phong模型计算（着色器详解）</h2><p>重点介绍一下渲染循环中phong模型中的几个分量。</p><p>lightingShader是我们箱子的着色器程序，或许他叫box shader会更合适些</p><pre><code>    while (!glfwWindowShouldClose(window))    &#123;    ...        lightingShader.use();        lightingShader.setVec3(&quot;light.position&quot;, lightPos);        lightingShader.setVec3(&quot;viewPos&quot;, camera.Position);                // light properties        lightingShader.setVec3(&quot;light.ambient&quot;, 0.2f, 0.2f, 0.2f);        lightingShader.setVec3(&quot;light.diffuse&quot;, 0.5f, 0.5f, 0.5f);        lightingShader.setVec3(&quot;light.specular&quot;, 1.0f, 1.0f, 1.0f);                // material properties        lightingShader.setVec3(&quot;material.specular&quot;, 0.5f, 0.5f, 0.5f);        lightingShader.setFloat(&quot;material.shininess&quot;, 64.0f);        &#125;</code></pre><p>如果对冯模型有了解的话（下次我自己看的时候估计会觉得是废话23333）</p><p>会知道在shader里面的计算是把<strong>环境光（ambient）漫反射（diffuse）高光（specular）</strong>的贡献相加</p><p>三个部分的计算便是由由我们传入的uniform值来参与的。</p><p>还记得片元着色器的职责是决定一个片元的颜色吧，这次我们展示一个完整的片元着色器：</p><pre><code>#version 330 coreout vec4 FragColor;struct Material &#123;    sampler2D diffuse;    vec3 specular;        float shininess;&#125;; struct Light &#123;    vec3 position;    vec3 ambient;    vec3 diffuse;    vec3 specular;&#125;;in vec3 FragPos;  in vec3 Normal;  in vec2 TexCoords;  uniform vec3 viewPos;uniform Material material;uniform Light light;void main()&#123;    // ambient    vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb;          // diffuse     vec3 norm = normalize(Normal);    vec3 lightDir = normalize(light.position - FragPos);    float diff = max(dot(norm, lightDir), 0.0);    vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb;          // specular    vec3 viewDir = normalize(viewPos - FragPos);    vec3 reflectDir = reflect(-lightDir, norm);      float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);    vec3 specular = light.specular * (spec * material.specular);              vec3 result = ambient + diffuse + specular;    FragColor = vec4(result, 1.0);&#125; </code></pre><p>环境光部分，我们这里就暂且认为环境光是我们的物体颜色，毕竟我们现在也做不出什么全局光照。</p><p>所以这里我们直接拿纹理和微弱的光照分量相乘就行</p><hr><p>漫反射光照能对物体产生显著的视觉影响，或者说物体呈现出什么样子就是漫反射决定的。</p><p>计算漫反射需要<strong>法线</strong>和<strong>入射光线</strong>，入射光线是我们由上阶段的顶点着色器输出的顶点坐标（世界坐标系）和光照计算而来的</p><p>这里的法线则是很有意思的地方，本身我们渲染的并不是一个箱子的模型，而是一个个手填的顶点</p><p>不存在什么表面更不存在什么法线，所以法线我们也是手填的（233333）</p><p>最后乘上<strong>漫反射系数</strong>，这决定了这部分的贡献是如何的。</p><p>所以尽管计算部分是参照了<strong>兰伯特光照模型</strong>，但我们在背光处也能看到物体的纹理，这便是由不真实的法线造成的。</p><hr><p>高光部分会复杂些，需要<strong>观察向量，反射方向，光泽度。</strong></p><p>观察方向由我们填入的camera.position和顶点计算得出。</p><p>反射方向的计算是一个耗时的计算，若改成计算半程向量（half vector）便能加速此部分的计算，也能得到不错的效果（布林冯）</p><hr><p>光泽度则影响高光亮点的大小。在公式里面扮演指数的部分，光泽度越高亮点就越小。</p><p>最后我们会乘上<strong>高光反射系数</strong>，这里填的（1.0,1.0,1.0），因为我们理所当然觉得高光很明显。</p><p>如此一来便完成了phong模型的着色部分的计算，我们便能渲出我们可爱的小箱箱了。</p><hr><p>完成这篇水博客之后感觉精神好了很多，不像之前那样一看到vs就烦躁了，学习的欲望也重新被激起了</p><p>今天没什么干劲了，明天再努力吧.jpg</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;写这篇博客的时候我还在我老家的床上，给自己放了两三天的假，决定写点东西。&lt;/p&gt;
&lt;p&gt;在经历了visual studio的链接失败和着色器编译失败之后&lt;/p&gt;
&lt;p&gt;深感自己力量渺小，无法棒打vs设计师（胡言乱语）&lt;/p&gt;
&lt;p&gt;再加上之前学的有些快而不扎实，复制源码跑动了看一遍就粗略带过（有时甚至跑不动）&lt;/p&gt;
&lt;p&gt;所以写这篇救命博客来挽救一下自己岌岌可危的大脑。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>温故知新UE4（网络同步）</title>
    <link href="https://aprilnavi.github.io/2021/12/21/2021-12-21-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0UE4%EF%BC%88%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5%EF%BC%89/"/>
    <id>https://aprilnavi.github.io/2021/12/21/2021-12-21-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0UE4%EF%BC%88%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5%EF%BC%89/</id>
    <published>2021-12-21T07:06:58.000Z</published>
    <updated>2021-12-22T09:31:15.480Z</updated>
    
    <content type="html"><![CDATA[<p>在开发完ue的demo后，回头总结了一些心得，趁着闲暇就记录下来。</p><span id="more"></span><p>这一篇看上去一点也不ue4，等熟了ue4的网络同步再来补相关部分。</p><h2 id="TCP三四次握手"><a href="#TCP三四次握手" class="headerlink" title="TCP三四次握手"></a>TCP三四次握手</h2><h3 id="创建连接（三次握手）"><a href="#创建连接（三次握手）" class="headerlink" title="创建连接（三次握手）"></a>创建连接（三次握手）</h3><p>第一次：客户端尝试连接服务器，向服务器发送syn包（seq＝x）。客户端进入SYN_SEND状态。</p><p>第二次：服务器接收客户端的syn包，同时向客户端发送一个SYN包（seq=y，ack＝x+1），同时发送一个ACK，即发送的是ACK+SYN，服务器进入SYN_RECV状态</p><p>第三次：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（seq=x+1，ack＝y+1），客户端和服务器进入Establish，TCP连接建立完成。</p><hr><h3 id="释放连接（四次握手）"><a href="#释放连接（四次握手）" class="headerlink" title="释放连接（四次握手）"></a>释放连接（四次握手）</h3><p>第一次：客户端进程发出连接释放报文FIN，并停止发送数据。客户端进入FIN_WAIT1状态。</p><p>第二次：服务器收到连接释放报文，发出确认报文ACK（ack=u+1，seq=v），服务器进入CLOSE_WAIT状态。此时客户端不接受数据，但若服务器发送数据，客户端依然要接受。客户端收到服务器的确认请求，进入FIN_WAIT2状态。</p><p>第三次：服务器将最后的数据发送完，向客户端发送释放连接报文FIN（ack＝u+1，seq=w），服务器进入LAST_ACK状态。</p><p>第四次：客户端收到服务器的连接释放报文，必须发出确认报文ACK（ack=w+1，seq=u+1），客户端进入TIME_WAIT状态，等待2xMSL（最长报文寿命时间），进入CLOSED，服务器收到ACK立即进入CLOSED。</p><h3 id="一些之外的思考"><a href="#一些之外的思考" class="headerlink" title="一些之外的思考"></a>一些之外的思考</h3><p><strong>为什么建立连接是三次握手，释放连接是四次握手？</strong></p><p>因为建立连接时服务器收到客户端的SYN时，可以同时发送一个ACK加SYN。释放连接时由于不知道是否还要继续传输文件，SOCKET没有立即关闭，所以只能发送一个ACK。</p><p><strong>为什么TIME_WAIT状态需要经过2MSL才能进入CLOSE？</strong></p><p>我们得假设网络是不可靠的。TIME_WAIT用来重发可能丢失的ACK。当服务器没有收到ACK时，会一直重复发送FIN，所以服务端不能关闭，得确保在2MSL内没有收到FIN才能进入CLOSED。其中2MSL是一个发送和一个回复所需的最大时间。</p><p><strong>为什么两次握手不能完成TCP连接创建？</strong></p><p>若只有两次连接，在服务器传回给客户端的应答丢失的情况下，客户端不知道服务器是否准备好，会认为连接未建立而忽略服务器发来的任何分组，只等待ACK。而服务器会重复发送同样的分组，从而造成死锁。</p><hr><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><ul><li>TCP面向连接，UDP无连接</li><li>TCP面向字节流，UDP面向报文</li><li>TCP提供可靠性（按序发送，有序到达，超时重传），UDP只尽力而为，不保证任何事。</li><li>TCP首部20字节，所需资源多，而UDP只占用8字节</li><li>TCP有流量控制和拥塞控制，而UDP没有（拥塞不会影响发送端的发送速率）</li><li>TCP只支持点对点，而UDP可以一对一，一对多，多对多。</li></ul><h2 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a>网络同步</h2><p><strong>RPC</strong></p><p>即远程过程调用，本地调用远程提供的函数。因为不是一个内存空间，需要网络来表达调用的语义和数据，而不能直接调用。</p><p>带来的问题：<strong>Call ID映射</strong>（让服务器知道我调用是哪个函数），<strong>序列化与反序列化</strong>（参数需要通过一种标准化的格式来传输，将对象转换为一系列字节流），<strong>网络传输</strong></p><p><strong>属性同步</strong></p><p>对象A的属性更改了，其他端的对应属性也要更改。一般是服务器更改同步到其他客户端。</p><hr><h3 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h3><p>帧同步只同步操作，大部分逻辑在客户端上运行，服务器主要用于验证和广播，逻辑易实现，数据量少，可重播，一致性好。一个玩家卡了所有人都卡。</p><h3 id="状态同步"><a href="#状态同步" class="headerlink" title="状态同步"></a>状态同步</h3><p>同步游戏的各种状态。客户端上传操作到服务器，服务器收到后运算结果，把各个状态广播给各个客户端，客户端根据状态展现不同的内容。</p><p>状态同步是一种不严谨的同步，对延迟的要求并不高。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>帧同步客户端一致性全程一致，状态同步中途可能有变化。</p><p>延迟方面帧同步要求搞，状态同步要求低。</p><p>流量方面，帧同步的流量与操作数量成正比，而状态同步与物体数量成正比。</p><p>服务器的任务上来看，帧同步服务器做的是同步操作，而状态同步的服务器则需要接受输入，进行全局仿真，状态的复制。</p><p>客户端的任务上来看，帧同步客户端做的是全局仿真，而状态同步客户端则是做局部游戏世界的展示。</p><p>断线重连，状态同步更容易，帧同步要从头开始运行（王者荣耀）。</p><p>开发效率上来看，帧同步的开发效率很高，接近单机开发。状态同步需要前后台联合开发。</p><p>安全性来看，帧同步安全性低。而状态同步在服务器端安全性高，但客户端有作弊可能。</p><h3 id="修复延迟"><a href="#修复延迟" class="headerlink" title="修复延迟"></a>修复延迟</h3><p>插值，预测，缓存，延迟补偿</p><hr><h2 id="UE4网络同步架构"><a href="#UE4网络同步架构" class="headerlink" title="UE4网络同步架构"></a>UE4网络同步架构</h2><p>以CS模型为基础，做了面向对象风格的封装，网络代码和游戏逻辑完全分离，网络同步支持可视化编程，使用UDP协议通信。</p><p><strong>为什么使用纯UDP？</strong>‘</p><p>TCP的可靠性无法定制，且游戏中许多数据不要求可靠。</p><p>TCP与UDP都是基于IP协议，底层会互相干扰，混用也会增加设计复杂度。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在开发完ue的demo后，回头总结了一些心得，趁着闲暇就记录下来。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>温故知新UE4（游戏模式）</title>
    <link href="https://aprilnavi.github.io/2021/12/20/2021-12-21%20%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0UE4%EF%BC%88%E6%B8%B8%E6%88%8F%E6%A8%A1%E5%BC%8F%EF%BC%89/"/>
    <id>https://aprilnavi.github.io/2021/12/20/2021-12-21%20%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0UE4%EF%BC%88%E6%B8%B8%E6%88%8F%E6%A8%A1%E5%BC%8F%EF%BC%89/</id>
    <published>2021-12-20T04:31:47.000Z</published>
    <updated>2021-12-21T10:19:27.565Z</updated>
    
    <content type="html"><![CDATA[<p>在开发完ue的demo后，回头总结了一些心得，趁着闲暇就记录下来。</p><span id="more"></span><ul><li>万事万物皆继承自UObject(CG，Reflection，Metadata，Serialization，Editable)</li><li>从Actor开始具有一些生命特征(Spawn，Destory，Tick，Replication(网络复制))</li><li>Pawn可以被Controller控制，有Movement，Input等基本响应接口，State来记录玩家状态。Actor正是通过各种Component组合成Pawn。Pawn是可控生命体的基础。</li><li>Character是一个特殊的Pawn，默认自带Collision，Skeletal Mesh，Movement移动组件</li></ul><hr><ul><li>构造函数的初始化在Begin之前，因此组件以及其他数据的初始化，若需要场景其他数据，则初始化得放在Begin里面。</li><li>Gamemode记录了初始的默认Pawn，HUD，Playercontroller等信息。当gamemode满足不了关卡配置时，会在关卡蓝图做一些逻辑配置。Gamemode更适合用来制定规则和检测规则。</li></ul><hr><ul><li>据大佬所说，开发游戏用的最多的设计模式是单例（懒汉式，线程安全），观察者，工厂模式</li><li>物理和AI是固定步长更新。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在开发完ue的demo后，回头总结了一些心得，趁着闲暇就记录下来。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
